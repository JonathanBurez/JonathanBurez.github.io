<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Switzerland Cycling Adventure Tracker</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://cdn.maptiler.com/maptiler-sdk-js/v3.0.1/maptiler-sdk.umd.min.js"></script>
    <link href="https://cdn.maptiler.com/maptiler-sdk-js/v3.0.1/maptiler-sdk.css" rel="stylesheet" />
    <script src="https://cdn.maptiler.com/leaflet-maptilersdk/v4.0.2/leaflet-maptilersdk.umd.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        #header {
            background-color: #e63946;
            color: white;
            padding: 10px;
            text-align: center;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        #container {
            display: flex;
            flex-direction: column;
            height: 10vh;
        }
        #map {
            flex: 1;
            min-height: 60vh;
            position: relative;
        }
        /* Add this to your existing styles */
        #info-panel {
            position: absolute;
            top: 10px;
            left: 10px;
            width: 150px;
            background-color: rgba(255, 255, 255, 0.9);
            padding: 5px;
            border-radius: 8px;
            z-index: 1000;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            transition: transform 0.3s ease;
            font-size: 12px;
        }

        .info-panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
            margin-bottom: 5px;
        }

        .info-panel-title {
            font-weight: bold;
            margin: 0;
        }

        .info-panel-toggle {
            font-size: 12px;
        }

        .info-panel-content {
            overflow: hidden;
            transition: max-height 0.3s ease;
        }

        .info-panel-collapsed .info-panel-content {
            max-height: 0;
            overflow: hidden;
        }

        .info-panel-collapsed .info-panel-toggle {
            transform: rotate(180deg);
        }
        #trip-stats {
            display: flex;
            flex-direction: column;
            gap: 10px;
            font-size: 12px;
        }
        .stat-box {
            background-color: white;
            padding: 10px;
            border-radius: 6px;
            text-align: center;
        }
        .stat-value {
            font-size: 16px;
            font-weight: bold;
            color: #e63946;
        }
        .stat-label {
            color: #457b9d;
        }
        #photo-gallery {
            display: flex;
            overflow-x: auto;
            gap: 10px;
            padding: 10px 0;
        }
        .photo-thumbnail {
            width: 150px;
            height: 150px;
            object-fit: cover;
            border-radius: 8px;
            cursor: pointer;
            transition: transform 0.2s;
        }
        .photo-thumbnail:hover {
            transform: scale(1.05);
        }
        #photo-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.8);
            z-index: 1000;
            justify-content: center;
            align-items: center;
        }
        #modal-content {
            max-width: 80%;
            max-height: 80%;
        }
        #modal-image {
            max-width: 100%;
            max-height: 80vh;
            border-radius: 8px;
        }
        #modal-caption {
            color: white;
            text-align: center;
            padding: 10px;
        }
        #close-modal {
            position: absolute;
            top: 20px;
            right: 30px;
            color: white;
            font-size: 12px;
            cursor: pointer;
        }
        .custom-popup .leaflet-popup-content-wrapper {
            background-color: rgba(255, 255, 255, 0.9);
            border-radius: 8px;
        }
        .popup-image {
            width: 200px;
            border-radius: 4px;
            margin-bottom: 5px;
        }
        .popup-time {
            font-size: 12px;
            color: #666;
        }
        #last-update {
            text-align: center;
            margin-top: 10px;
            font-style: italic;
            color: #666;
        }
        #stage-selector {
            display: flex;
            justify-content: right;
            margin: 10px 0;
        }
        .stage-dropdown {
            background-color: #457b9d;
            color: white;
            border: none;
            padding: 10px 10px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            min-width: 200px;
            transition: all 0.2s;
        }
        .stage-dropdown:hover {
            background-color: #1d3557;
        }
        .stage-dropdown:focus {
            outline: none;
            box-shadow: 0 0 0 2px rgba(29, 53, 87, 0.5);
        }
        .legend {
            padding: 10px;
            background-color: white;
            border-radius: 5px;
            box-shadow: 0 1px 4px rgba(0,0,0,0.2);
            line-height: 1;
        }
        .legend-item {
            display: flex;
            align-items: center;
            margin-bottom: 5px;
        }
        .legend-color {
            width: 20px;
            height: 5px;
            margin-right: 8px;
        }
        .cyclist-icon {
            animation: pulse 1.5s infinite;
        }
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.2); }
            100% { transform: scale(1); }
        }
        #profileContainer {
        height: 30vh; /* Set the height to 30% of viewport height */
        width: 100vw;
        position: relative;
        background-color: #f8f9fa;
        border-top: 1px solid #ddd;
        }
        #elevationChart {
            width: 100vw;
            height: 100%;
        }
        .legend {
            padding: 10px;
            background-color: white;
            border-radius: 5px;
            box-shadow: 0 1px 4px rgba(0,0,0,0.2);
            line-height: 1;
            max-width: 200px;
        }
        .legend-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }

        .legend-toggle {
            cursor: pointer;
            font-size: 12px;
        }

        .legend-content {
            display: block;
        }

        .legend-item {
            display: flex;
            align-items: center;
            margin-bottom: 5px;
        }

        .legend-color {
            width: 20px;
            height: 5px;
            margin-right: 8px;
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="header">
            <div id="stage-selector">
                <select id="stage-dropdown" class="stage-dropdown">
                    <option value="-1" selected>Whole Trip</option>
                    <option value="0">Stage 1</option>
                    <option value="1">Stage 2</option>
                    <option value="2">Stage 3</option>
                    <option value="3">Stage 4</option>
                    <option value="4">Stage 5</option>
                    <option value="5">Stage 6</option>
                    <option value="6">Stage 7</option>
                    <option value="7">Stage 8</option>
                    <option value="8">Stage 9</option>
                    <option value="9">Stage 10</option>
                    <option value="10">Stage 11</option>
                </select>
            </div>
        </div>
        <div id="map"></div>
        <div id="profileContainer"></div>
        <div id="info-panel">
          document.getElementById('info-panel').innerHTML = `
              <div class="info-panel-header">
                  <h3 class="info-panel-title">Trip Information</h3>
                  <span class="info-panel-toggle">▼</span>
              </div>
              <div class="info-panel-content">
              </div>
          `;
        </div>

    <div id="photo-modal">
        <span id="close-modal">&times;</span>
        <div id="modal-content">
            <img id="modal-image" src="" alt="Photo">
            <div id="modal-caption"></div>
        </div>
    </div>

    <script>
      // Modify Chart.js loading
      function loadChartJS() {
          return new Promise((resolve, reject) => {
              const chartScript = document.createElement('script');
              chartScript.src = "https://cdn.jsdelivr.net/npm/chart.js";
              chartScript.onload = () => {
                  console.log('Chart.js loaded successfully');
                  resolve();
              };
              chartScript.onerror = reject;
              document.head.appendChild(chartScript);
          });
      }
      // Initialize the (Leaflet) map centered on Switzerland
      const map = L.map('map').setView([46.8182, 8.2275], 8);
      // Maptiler API key
      const key = 'Rx7It18F2RfVcfR5JyxV';
      const mtLayer = L.maptiler.maptilerLayer({
        apiKey: key,
        style: 'https://api.maptiler.com/maps/ch-swisstopo-lbm/style.json', //optional
      }).addTo(map);

        // Variables to store trip data
        let currentPosition = null;
        let positionMarker = null;
        let actualPath = [];
        let pathLine = null;
        let photos = [];
        
        // Stage colors (11 distinct colors)
        const stageColors = [
            '#d73027', // donkerrood
            '#4575b4', // donkerblauw
            '#1a9850', // donkergroen
            '#7b3294', // donkerpaars
            '#e66101', // diep oranje
            '#ffcc00', // donkergeel
            '#a6611a', // warm bruin
            '#d01c8b', // magenta
            '#666666', // donkergrijs
            '#1f968b', // donker teal
            '#f46d43'  // warm koraal
        ];
        
        // Store all route data
        const routes = {
            stages: [],
            current: 0
        };
        
        // Create a foldable legend
        const legend = L.control({position: 'bottomright'});
        legend.onAdd = function (map) {
            const div = L.DomUtil.create('div', 'legend');
            div.innerHTML = `
                <div class="legend-header">
                    <h4>Legend</h4>
                    <span class="legend-toggle">▼</span>
                </div>
                <div class="legend-content">
                    ${Array.from({length: 11}, (_, i) => `
                        <div class="legend-item">
                            <div class="legend-color" style="background-color: ${stageColors[i]};"></div>
                            <span>Stage ${i+1}</span>
                        </div>
                    `).join('')}
                    <div class="legend-item">
                        <span style="margin-right: 8px;">🚴‍♂️</span>
                        <span>Current Position</span>
                    </div>
                    <div class="legend-item">
                        <span style="margin-right: 8px;">📷</span>
                        <span>Photo</span>
                    </div>
                </div>
            `;
            
            // Add click event to toggle legend
            const toggle = div.querySelector('.legend-toggle');
            const content = div.querySelector('.legend-content');
            
            toggle.addEventListener('click', function() {
                if (content.style.display === 'none') {
                    content.style.display = 'block';
                    toggle.textContent = '▼';
                } else {
                    content.style.display = 'none';
                    toggle.textContent = '▶';
                }
            });
            
            return div;
        };
        legend.addTo(map);
        
        // Create a marker for current position (initially hidden)
        const cyclistIcon = L.divIcon({
            html: '🚴‍♂️',
            className: 'cyclist-icon',
            iconSize: [30, 30],
            iconAnchor: [15, 15]
        });
        
        positionMarker = L.marker([0, 0], {
            icon: cyclistIcon,
            zIndexOffset: 1000
        });
        
        // Initialize the actual traveled path
        pathLine = L.polyline([], {
            color: '#e63946',
            weight: 5,
            opacity: 0.8
        }).addTo(map);
        
        // Function to parse GPX files
        async function parseGPX(url, stageIndex) {
            try {
                const response = await fetch(url);
                const gpxText = await response.text();
                
                // Parse GPX using DOM parser
                const parser = new DOMParser();
                const gpx = parser.parseFromString(gpxText, "text/xml");
                
                // Extract track points
                const trackPoints = [];
                const points = gpx.getElementsByTagName('trkpt');
                
                for (let i = 0; i < points.length; i++) {
                    const point = points[i];
                    const lat = parseFloat(point.getAttribute('lat'));
                    const lon = parseFloat(point.getAttribute('lon'));
                    
                    // Get elevation if available
                    let ele = 0;
                    const eleNode = point.getElementsByTagName('ele')[0];
                    if (eleNode) {
                        ele = parseFloat(eleNode.textContent);
                    }
                    
                    trackPoints.push([lat, lon, ele]);
                }
                
                // Create route object
                const route = {
                    index: stageIndex,
                    points: trackPoints,
                    distance: calculateRouteDistance(trackPoints),
                    elevation: calculateElevationGain(trackPoints),
                    line: L.polyline(trackPoints.map(p => [p[0], p[1]]), {
                        color: stageColors[stageIndex],
                        weight: 4,
                        opacity: 0.7
                    })
                };
                
                // Add to routes collection
                routes.stages[stageIndex] = route;
                
                // Add to map and fit bounds
                route.line.addTo(map);
                
                // Add start and end markers
                if (trackPoints.length > 0) {
                    const startPoint = trackPoints[0];
                    const endPoint = trackPoints[trackPoints.length - 1];
                    
                    L.marker([startPoint[0], startPoint[1]], {
                        title: `Stage ${stageIndex + 1} Start`,
                        icon: L.icon({
                            iconUrl: 'https://unpkg.com/leaflet@1.9.4/dist/images/marker-icon.png',
                            iconSize: [15, 25], // Reduce from default [25, 41] to smaller size
                            iconAnchor: [7, 25], // Adjust anchor point accordingly
                            popupAnchor: [1, -22] // Adjust popup anchor accordingly
                        })
                    }).addTo(map)
                    .bindPopup(`<strong>Stage ${stageIndex + 1} Start</strong>`);
                    
                    L.marker([endPoint[0], endPoint[1]], {
                        title: `Stage ${stageIndex + 1} End`,
                        icon: L.icon({
                            iconUrl: 'https://unpkg.com/leaflet@1.9.4/dist/images/marker-icon.png',
                            iconSize: [15, 25], // Reduce from default [25, 41] to smaller size
                            iconAnchor: [7, 25], // Adjust anchor point accordingly
                            popupAnchor: [1, -22] // Adjust popup anchor accordingly
                        })
                    }).addTo(map)
                    .bindPopup(`<strong>Stage ${stageIndex + 1} End</strong>`);
                }
                
                return route;
            } catch (error) {
                console.error(`Error loading GPX for stage ${stageIndex + 1}:`, error);
                return null;
            }
        }
        
        // Calculate distance of a route
        function calculateRouteDistance(points) {
            let distance = 0;
            for (let i = 1; i < points.length; i++) {
                const prevPoint = L.latLng(points[i-1][0], points[i-1][1]);
                const currPoint = L.latLng(points[i][0], points[i][1]);
                distance += prevPoint.distanceTo(currPoint);
            }
            return distance / 1000; // Convert to kilometers
        }
        
        // Calculate elevation gain
        function calculateElevationGain(points) {
            let gain = 0;
            for (let i = 1; i < points.length; i++) {
                const elevDiff = points[i][2] - points[i-1][2];
                if (elevDiff > 0) {
                    gain += elevDiff;
                }
            }
            return gain;
        }
        
        // Function to handle stage dropdown change
        function handleStageChange() {
            const dropdown = document.getElementById('stage-dropdown');
            const selectedValue = parseInt(dropdown.value);
            
            if (selectedValue === -1) {
                // Whole trip selected - show all stages and fit all bounds
                showWholeTrip();
            } else {
                // Individual stage selected
                focusOnStage(selectedValue);
                createElevationProfile(selectedValue);
            }
        }
        
        // Function to show the whole trip
        function showWholeTrip() {
            // Zoom to fit all routes
            const bounds = [];
            let totalDistance = 0;
            let totalElevation = 0;
            
            for (let i = 0; i < routes.stages.length; i++) {
                if (routes.stages[i]) {
                    const stage = routes.stages[i];
                    const stagePoints = stage.points.map(p => [p[0], p[1]]);
                    bounds.push(...stagePoints);
                    
                    // Sum up stats
                    totalDistance += stage.distance;
                    totalElevation += stage.elevation;
                }
            }
            
            if (bounds.length > 0) {
                map.fitBounds(bounds.map(p => L.latLng(p[0], p[1])));
                
                // Update display
                document.getElementById('current-stage').textContent = `All`;
                document.getElementById('distance-traveled').textContent = totalDistance.toFixed(1);
                document.getElementById('elevation-gain').textContent = totalElevation.toFixed(0);
            } else {
                // Fallback to Switzerland view if no routes loaded
                map.setView([46.8182, 8.2275], 8);
            }
            
            // Clear elevation profile when showing whole trip
            const profileContainer = document.getElementById('profileContainer');
            profileContainer.innerHTML = '';
        }
        
        // Focus on a specific stage
        function focusOnStage(stageIndex) {
            if (routes.stages[stageIndex]) {
                const route = routes.stages[stageIndex];
                map.fitBounds(route.line.getBounds());
                
                // Update current stage display
                document.getElementById('current-stage').textContent = `${stageIndex + 1}/11`;
                
                // Update elevation display
                document.getElementById('elevation-gain').textContent = 
                    route.elevation.toFixed(0);
                
                // Update distance display
                document.getElementById('distance-traveled').textContent = 
                    route.distance.toFixed(1);
            }
        }
        // Dropbox app.key tgn7d59fu7troh6
        // Dropbox access token   sl.u.AFp3afADUo3svpMYisyU4pJbcwTLX1ktRF3th8wNHpBav_q1PgrdVwkLZa9eDzHVW0glUKpc7Jzomkr0dvAAJjaDmttDXA40KZVdZ92XrHEw8Ne_nMVaT4UZQrvRYkOasS0VIN5P9zgSWNazIwjudEnqKHLPTYBpUD4O0Sq5VZ79Xw_g9LvAyoZmptGwoS7MCEtiOmWNk0Bzm3YCbGxs5HKvoqXTPQ0aHk9N0Fon1jJxwkXzJi_wKFeALiEgrjo5rNqVfofYuvYUoCLC-Yt94gD5vQf3u5gJdXalQs3pnXDDPGsr9P-q0GvQGiYyWhi1lPd1x-BVIOnJlOPL9sizJFlhjOBc663ixDQ_nbLKubSlusr7ndkSwowYR9LvvrBdbpKPnqYUih4gk_AkEkkgLgkGxOSCGZvRvzDdOlI5kK6D0h_dxFXwEvKD7NXGpOqBjVn0y8ivgTwq25P9lr_yz90G-SZW0slLc2WRJ_mZb0u8y6zeukaPIZ6JyBHPZt_MU6wB0QdALQiP2ht7Nm00F3BSrNIzzy1qf0g8_mMwKlYjrijuIO40lHCQDoeTWAu7W7XK2WNQHq15AKvYPvN69ZdsDaakcA-Ij0OK5l2lICQpcNU4wiHAJgufuaM2cJdQMSjZSHoYVzcXCBVHA_nmJ0HYQP-tsVZQbyOUeoG3uyQ-TYPnw8tqr1SnlnjWkmykxVTUD3oKBWdnJzw7eeHzDTEUB2h7nWwVrXoBSiAGiThh1xYFxIuiZrQNkJvN8OukuH9g7SCpkfAyvQ6Uh3O0dJXhWtmDtb6-XH48m5IsGhZMby6rZUHhj7VWib3HQV7riCt7a1Fz3MeFjofSwBRfj4PuzQTLKo6W5BbgU5-EAGY84BaNLua5-fczHMTAarwQI6VJFXd2brTi7VAaHdcJ7p8-F939qmOpf8jK_v3YKahdTLL-vavlF3pOrUtYcNwUW_EuKVrVcWQNDw5MjaOOMaK0azwaNMeHMi2d-e5yG1u0cSe4EYuwYma3QY6FDWd1sdmHL9wgDi5fwGslqcNgMD-8uD6k1lco1MHpCHXUqT6t4FgK4zJd1r9jRAKjerCuw02HexrGaVL_J4lZQNgKPTPoUt4mE2E5Mc-vslY6eZoRFbIfeZIQvdTybs-aU9UQ8q_XxgUXl2kcBrQjxM_KFMiK6CbmivU6nlyEFFUxJa6HG-dNox_4g_WEmVDanZZfZ8feI5Ic46XYMcz36wXKpeZIYVGmdlTJ1Jkp2M_-_vtks5nQZ14rcCDf8JkWoulu661D-Q284ba96dAfsbopLLqO
        // Dropbox appFolder   Hope1000
        // Dropbox API Configuration
        const DROPBOX_ACCESS_TOKEN = 'sl.u.AFp3afADUo3svpMYisyU4pJbcwTLX1ktRF3th8wNHpBav_q1PgrdVwkLZa9eDzHVW0glUKpc7Jzomkr0dvAAJjaDmttDXA40KZVdZ92XrHEw8Ne_nMVaT4UZQrvRYkOasS0VIN5P9zgSWNazIwjudEnqKHLPTYBpUD4O0Sq5VZ79Xw_g9LvAyoZmptGwoS7MCEtiOmWNk0Bzm3YCbGxs5HKvoqXTPQ0aHk9N0Fon1jJxwkXzJi_wKFeALiEgrjo5rNqVfofYuvYUoCLC-Yt94gD5vQf3u5gJdXalQs3pnXDDPGsr9P-q0GvQGiYyWhi1lPd1x-BVIOnJlOPL9sizJFlhjOBc663ixDQ_nbLKubSlusr7ndkSwowYR9LvvrBdbpKPnqYUih4gk_AkEkkgLgkGxOSCGZvRvzDdOlI5kK6D0h_dxFXwEvKD7NXGpOqBjVn0y8ivgTwq25P9lr_yz90G-SZW0slLc2WRJ_mZb0u8y6zeukaPIZ6JyBHPZt_MU6wB0QdALQiP2ht7Nm00F3BSrNIzzy1qf0g8_mMwKlYjrijuIO40lHCQDoeTWAu7W7XK2WNQHq15AKvYPvN69ZdsDaakcA-Ij0OK5l2lICQpcNU4wiHAJgufuaM2cJdQMSjZSHoYVzcXCBVHA_nmJ0HYQP-tsVZQbyOUeoG3uyQ-TYPnw8tqr1SnlnjWkmykxVTUD3oKBWdnJzw7eeHzDTEUB2h7nWwVrXoBSiAGiThh1xYFxIuiZrQNkJvN8OukuH9g7SCpkfAyvQ6Uh3O0dJXhWtmDtb6-XH48m5IsGhZMby6rZUHhj7VWib3HQV7riCt7a1Fz3MeFjofSwBRfj4PuzQTLKo6W5BbgU5-EAGY84BaNLua5-fczHMTAarwQI6VJFXd2brTi7VAaHdcJ7p8-F939qmOpf8jK_v3YKahdTLL-vavlF3pOrUtYcNwUW_EuKVrVcWQNDw5MjaOOMaK0azwaNMeHMi2d-e5yG1u0cSe4EYuwYma3QY6FDWd1sdmHL9wgDi5fwGslqcNgMD-8uD6k1lco1MHpCHXUqT6t4FgK4zJd1r9jRAKjerCuw02HexrGaVL_J4lZQNgKPTPoUt4mE2E5Mc-vslY6eZoRFbIfeZIQvdTybs-aU9UQ8q_XxgUXl2kcBrQjxM_KFMiK6CbmivU6nlyEFFUxJa6HG-dNox_4g_WEmVDanZZfZ8feI5Ic46XYMcz36wXKpeZIYVGmdlTJ1Jkp2M_-_vtks5nQZ14rcCDf8JkWoulu661D-Q284ba96dAfsbopLLqOKEN'; // Replace with your actual access token
        const PHOTO_FOLDER_PATH = '/Photos/Hope1000'; // Path to your photos folder in Dropbox
        const REFRESH_INTERVAL = 5 * 60 * 1000; // 30 minutes in milliseconds

        // Function to fetch photos from Dropbox
        async function fetchPhotosFromDropbox() {
            try {
                // First, list files in the specified folder
                const response = await fetch('https://api.dropboxapi.com/2/files/list_folder', {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${DROPBOX_ACCESS_TOKEN}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        path: PHOTO_FOLDER_PATH,
                        recursive: false,
                        include_media_info: true
                    })
                });

                const data = await response.json();
                
                if (!data.entries || data.error) {
                    console.error('Error fetching Dropbox files:', data.error || 'No entries found');
                    return;
                }

                // Filter for image files only (jpg, png, etc.)
                const imageFiles = data.entries.filter(entry => 
                    entry['.tag'] === 'file' && 
                    /\.(jpg|jpeg|png|gif)$/i.test(entry.name)
                );
                
                // For each image, get the metadata and download URL
                for (const file of imageFiles) {
                    // Check if we've already processed this file
                    if (processedFiles.has(file.id)) continue;
                    
                    try {
                        // Get temporary link for the file
                        const linkResponse = await fetch('https://api.dropboxapi.com/2/files/get_temporary_link', {
                            method: 'POST',
                            headers: {
                                'Authorization': `Bearer ${DROPBOX_ACCESS_TOKEN}`,
                                'Content-Type': 'application/json'
                            },
                            body: JSON.stringify({
                                path: file.path_lower
                            })
                        });
                        
                        const linkData = await linkResponse.json();
                        
                        if (linkData.link) {
                            // Attempt to extract location data from the filename or metadata
                            // Format expected: YYYY-MM-DD_HH-MM-SS_lat_lon.jpg (e.g., 2025-04-02_14-30-00_46.8182_8.2275.jpg)
                            const filenameParts = file.name.split('_');
                            let lat, lon, timestamp;
                            
                            if (filenameParts.length >= 4) {
                                // Try to extract coordinates from filename
                                lat = parseFloat(filenameParts[filenameParts.length - 2]);
                                lon = parseFloat(filenameParts[filenameParts.length - 1].split('.')[0]);
                                
                                // Extract timestamp from filename
                                const datePart = filenameParts[0];
                                const timePart = filenameParts[1].replace(/-/g, ':');
                                timestamp = new Date(`${datePart}T${timePart}`).toISOString();
                            }
                            
                            // If no coordinates in filename, use file metadata or default to a central Switzerland location
                            if (!lat || !lon || isNaN(lat) || isNaN(lon)) {
                                // Check if file has location metadata
                                if (file.media_info && 
                                    file.media_info.metadata && 
                                    file.media_info.metadata.location) {
                                    lat = file.media_info.metadata.location.latitude;
                                    lon = file.media_info.metadata.location.longitude;
                                } else {
                                    // Default to a location in Switzerland (you can adjust this)
                                    lat = 46.8182;
                                    lon = 8.2275;
                                }
                            }
                            
                            // If no timestamp extracted, use the file's server_modified date
                            if (!timestamp) {
                                timestamp = new Date(file.server_modified).toISOString();
                            }
                            
                            // Create a caption from the filename (remove extension and underscores)
                            const caption = file.name.replace(/\.[^/.]+$/, "").replace(/_/g, " ");
                            
                            // Add photo to the map and gallery
                            addPhoto(lat, lon, linkData.link, caption, timestamp);
                            
                            // Mark this file as processed
                            processedFiles.add(file.id);
                        }
                    } catch (error) {
                        console.error(`Error processing Dropbox file ${file.name}:`, error);
                    }
                }
            } catch (error) {
                console.error('Error fetching photos from Dropbox:', error);
            }
        }

        // Set to track already processed files
        const processedFiles = new Set();

        // Start periodic syncing with Dropbox
        function startDropboxSync() {
            // Fetch photos immediately
            fetchPhotosFromDropbox();
            
            // Then fetch every 30 minutes
            setInterval(fetchPhotosFromDropbox, REFRESH_INTERVAL);
        }

        // Function to update position from Spot Gen4
        function updatePosition(lat, lon, timestamp) {
            if (!currentPosition) {
                positionMarker.setLatLng([lat, lon]).addTo(map);
            } else {
                positionMarker.setLatLng([lat, lon]);
            }
            
            currentPosition = [lat, lon];
            actualPath.push(currentPosition);
            
            // Update actual path line
            if (!pathLine) {
                pathLine = L.polyline(actualPath, {
                    color: '#e63946',
                    weight: 5,
                    opacity: 0.8
                }).addTo(map);
            } else {
                pathLine.setLatLngs(actualPath);
            }
            
            // Update last update time
            const updateTime = new Date(timestamp);
            document.getElementById('last-update').textContent = 
                'Last updated: ' + updateTime.toLocaleString();
            
            // Determine current stage based on position
            determineCurrentStage(lat, lon);
        }
        
        // Determine which stage the cyclist is currently on
        function determineCurrentStage(lat, lon) {
            const position = L.latLng(lat, lon);
            let closestStage = 0;
            let closestDistance = Infinity;
            
            for (let i = 0; i < routes.stages.length; i++) {
                if (routes.stages[i]) {
                    const stage = routes.stages[i];
                    const routePoints = stage.points.map(p => L.latLng(p[0], p[1]));
                    
                    // Find closest point on this route
                    let minDistance = Infinity;
                    for (const point of routePoints) {
                        const distance = position.distanceTo(point);
                        if (distance < minDistance) {
                            minDistance = distance;
                        }
                    }
                    
                    if (minDistance < closestDistance) {
                        closestDistance = minDistance;
                        closestStage = i;
                    }
                }
            }
            
            // Update current stage if it changed
            if (routes.current !== closestStage) {
                routes.current = closestStage;
                
                // Update dropdown to reflect current stage
                document.getElementById('stage-dropdown').value = closestStage.toString();
                
                // Update stats display
                document.getElementById('current-stage').textContent = `${closestStage + 1}/11`;
                
                if (routes.stages[closestStage]) {
                    document.getElementById('elevation-gain').textContent = 
                        routes.stages[closestStage].elevation.toFixed(0);
                    document.getElementById('distance-traveled').textContent = 
                        routes.stages[closestStage].distance.toFixed(1);
                }
            }
        }
        
        // Function to add a photo
        function addPhoto(lat, lon, imageUrl, caption, timestamp) {
            // Create a photo object
            const photo = {
                position: [lat, lon],
                imageUrl: imageUrl,
                caption: caption,
                timestamp: timestamp
            };
            
            photos.push(photo);
            
            // Add photo marker to map
            const photoMarker = L.marker([lat, lon], {
                icon: L.divIcon({
                    html: '📷',
                    className: 'photo-icon',
                    iconSize: [30, 30],
                    iconAnchor: [15, 15]
                })
            }).addTo(map);
            
            // Create popup with photo
            const popupContent = `
                <div class="photo-popup">
                    <img src="${imageUrl}" class="popup-image" alt="Photo">
                    <div>${caption}</div>
                    <div class="popup-time">${new Date(timestamp).toLocaleString()}</div>
                </div>
            `;
            
            photoMarker.bindPopup(popupContent, {
                className: 'custom-popup',
                maxWidth: 250
            });
            
            // Add to gallery
            const gallery = document.getElementById('photo-gallery');
            const thumbnail = document.createElement('img');
            thumbnail.src = imageUrl;
            thumbnail.className = 'photo-thumbnail';
            thumbnail.setAttribute('data-index', photos.length - 1);
            thumbnail.addEventListener('click', function() {
                openPhotoModal(parseInt(this.getAttribute('data-index')));
            });
            
            gallery.appendChild(thumbnail);
            
            // Update photo count
            document.getElementById('photos-shared').textContent = photos.length;
        }
        
        // Function to open the photo modal
        function openPhotoModal(index) {
            const photo = photos[index];
            document.getElementById('modal-image').src = photo.imageUrl;
            document.getElementById('modal-caption').textContent = 
                photo.caption + ' - ' + new Date(photo.timestamp).toLocaleString();
            document.getElementById('photo-modal').style.display = 'flex';
        }
        
        // Function to close the photo modal
        document.getElementById('close-modal').addEventListener('click', function() {
            document.getElementById('photo-modal').style.display = 'none';
        });

// Function to create elevation profile for a stage
function createElevationProfile(stageIndex) {
    if (!routes.stages[stageIndex]) return;
    
    const profileContainer = document.getElementById('profileContainer');
    profileContainer.innerHTML = '';
    
    // Create canvas for the chart
    const canvas = document.createElement('canvas');
    canvas.id = 'elevationChart';
    profileContainer.appendChild(canvas);
    
    // Extract elevation data from stage
    const stage = routes.stages[stageIndex];
    const elevationData = stage.points.map((point, index) => {
        // Calculate distance from start for each point
        let distanceFromStart = 0;
        if (index > 0) {
            for (let i = 1; i <= index; i++) {
                const prevPoint = L.latLng(stage.points[i-1][0], stage.points[i-1][1]);
                const currPoint = L.latLng(stage.points[i][0], stage.points[i][1]);
                distanceFromStart += prevPoint.distanceTo(currPoint);
            }
        }
        
        return {
            distance: distanceFromStart / 1000, // km
            elevation: point[2],
            lat: point[0],
            lon: point[1],
            index: index
        };
    });

    // Create position marker for hovering
    const hoverMarker = L.circleMarker([0, 0], {
        radius: 8,
        color: '#ff0000',
        fillColor: '#ff0000',
        fillOpacity: 0.5,
        weight: 2
    });
    
    // Create chart
    if (window.Chart) {
        const ctx = document.getElementById('elevationChart').getContext('2d');
        const chart = new Chart(ctx, {
            type: 'line',
            data: {
                datasets: [{
                    label: `Elevation Profile - Stage ${stageIndex + 1}`,
                    data: elevationData,
                    borderColor: stageColors[stageIndex],
                    backgroundColor: `${stageColors[stageIndex]}80`,
                    borderWidth: 2,
                    pointRadius: 0,
                    fill: true // Enable fill under the line
                }]
            },
 // Inside the createElevationProfile function, modify the options section of the Chart configuration:
            options: {
                responsive: true,
                maintainAspectRatio: false,
                parsing: {
                    xAxisKey: 'distance',
                    yAxisKey: 'elevation'
                },
                scales: {
                    x: {
                        type: 'linear',
                        title: {
                            display: true,
                            text: 'Distance (km)'
                        }
                    },
                    y: {
                        title: {
                            display: true,
                            text: 'Elevation (m)'
                        }
                    }
                },
                plugins: {
                    legend: {
                        display: false // Hide the legend
                    },
                    title: {
                        display: true,
                        text: `Elevation Profile - Stage ${stageIndex + 1}`
                    },
                    tooltip: {
                        mode: 'index',
                        intersect: false,
                        displayColors: false, // This removes the colored box
                        callbacks: {
                            title: function(context) {
                              return `Distance: ${context[0].raw.distance.toFixed(1)} km\nElevation: ${context[0].raw.elevation.toFixed(0)} m`;
                            },
                            label: function(context) {
                              return ``;
                            }
                        }
                    }
                },
                interaction: {
                    mode: 'index',
                    intersect: false
                }
            }
                    });
                    
                    // Add mouse event listeners to handle hover
                    canvas.addEventListener('mousemove', function(event) {
                        const points = chart.getElementsAtEventForMode(event, 'index', { intersect: false });
                        if (points.length > 0) {
                            const dataIndex = points[0].index;
                            const pointData = elevationData[dataIndex];
                            
                            // Update marker position
                            hoverMarker.setLatLng([pointData.lat, pointData.lon]);
                            
                            // Add marker to map if not already added
                            if (!map.hasLayer(hoverMarker)) {
                                hoverMarker.addTo(map);
                            }
                        }
                    });
                    
                    // Remove marker when mouse leaves the chart
                    canvas.addEventListener('mouseout', function() {
                        if (map.hasLayer(hoverMarker)) {
                            map.removeLayer(hoverMarker);
                        }
                    });
                }
            }

        // Load GPX files - replace these URLs with your actual GPX files
        async function loadGPXFiles() {
            // Add event listener for dropdown
            document.getElementById('stage-dropdown').addEventListener('change', handleStageChange);
            
            // Load stages
            parseGPX('https://raw.githubusercontent.com/JonathanBurez/JonathanBurez.github.io/refs/heads/main/Day01.gpx', 0);
            parseGPX('https://raw.githubusercontent.com/JonathanBurez/JonathanBurez.github.io/refs/heads/main/Day02.gpx', 1);
            parseGPX('https://raw.githubusercontent.com/JonathanBurez/JonathanBurez.github.io/refs/heads/main/Day03.gpx', 2);
            parseGPX('https://raw.githubusercontent.com/JonathanBurez/JonathanBurez.github.io/refs/heads/main/Day04.gpx', 3);
            parseGPX('https://raw.githubusercontent.com/JonathanBurez/JonathanBurez.github.io/refs/heads/main/Day05.gpx', 4);
            parseGPX('https://raw.githubusercontent.com/JonathanBurez/JonathanBurez.github.io/refs/heads/main/Day06.gpx', 5);
            parseGPX('https://raw.githubusercontent.com/JonathanBurez/JonathanBurez.github.io/refs/heads/main/Day07.gpx', 6);
            parseGPX('https://raw.githubusercontent.com/JonathanBurez/JonathanBurez.github.io/refs/heads/main/Day08.gpx', 7);
            parseGPX('https://raw.githubusercontent.com/JonathanBurez/JonathanBurez.github.io/refs/heads/main/Day09.gpx', 8);
            parseGPX('https://raw.githubusercontent.com/JonathanBurez/JonathanBurez.github.io/refs/heads/main/Day10.gpx', 9);
            parseGPX('https://raw.githubusercontent.com/JonathanBurez/JonathanBurez.github.io/refs/heads/main/Day11.gpx', 10);
            
            // Initialize with whole trip view
            setTimeout(showWholeTrip, 1000);
        }
        
        // Function to fetch spot data
        async function fetchSpotData() {
            try {
                // In a real implementation, you would connect to Spot API or feed
                // Example: `https://api.findmespot.com/spot-main-web/consumer/rest-api/2.0/public/feed/{feed-id}/message.json`
                
                const response = await fetch('YOUR_SPOT_API_ENDPOINT');
                const data = await response.json();
                
                // Process Spot data and update the map
                // This would depend on the structure of the Spot API response
                if (data && data.messages && data.messages.length > 0) {
                    const latestMessage = data.messages[0];
                    
                    // Update position (format depends on Spot API)
                    updatePosition(
                        latestMessage.latitude,
                        latestMessage.longitude,
                        latestMessage.dateTime
                    );
                }
            } catch (error) {
                console.error('Error fetching Spot data:', error);
            }
        }
        
// Modify initialization to wait for Chart.js
async function initApp() {
    // First load Chart.js
    await loadChartJS();

    // Then load GPX routes
    await loadGPXFiles();
    
    // Add the info panel header and toggle functionality
    const infoPanel = document.getElementById('info-panel');
    const infoPanelContent = infoPanel.innerHTML;
    
    // Wrap existing content in the panel content div
    infoPanel.innerHTML = `
        <div class="info-panel-header">
            <h3 class="info-panel-title">Trip Information</h3>
            <span class="info-panel-toggle">▼</span>
        </div>
        <div class="info-panel-content">
                  <div id="trip-stats">
                      <div class="stat-box">
                          <div class="stat-value" id="current-stage">0/11</div>
                          <div class="stat-label">Current Stage</div>
                      </div>
                      <div class="stat-box">
                          <div class="stat-value" id="distance-traveled">0</div>
                          <div class="stat-label">Kilometers</div>
                      </div>
                      <div class="stat-box">
                          <div class="stat-value" id="elevation-gain">0</div>
                          <div class="stat-label">Meters Climbed</div>
                      </div>
                      <div class="stat-box">
                          <div class="stat-value" id="photos-shared">0</div>
                          <div class="stat-label">Photos Shared</div>
                      </div>
                  </div>
                  <h2>Latest Photos</h2>
                  <div id="photo-gallery">
                      <!-- Photos will be added here dynamically -->
                  </div>
                  <div id="last-update">Last updated: Not yet started</div>
        </div>
    `;
    // Inside the initApp function, after setting the infoPanel.innerHTML, add this line:
    infoPanel.classList.add('info-panel-collapsed');

    // And change the toggle text:
    const toggle = document.querySelector('.info-panel-toggle');
    toggle.textContent = '▲';
    // Add event listener for toggle
    document.querySelector('.info-panel-header').addEventListener('click', function() {
        const panel = document.getElementById('info-panel');
        panel.classList.toggle('info-panel-collapsed');
        
        const toggle = document.querySelector('.info-panel-toggle');
        if (panel.classList.contains('info-panel-collapsed')) {
            toggle.textContent = '▲';
        } else {
            toggle.textContent = '▼';
        }
    });
    // Start Dropbox synchronization
    startDropboxSync();
}
        
        // Start the application
        initApp();
        
        // DEMO FUNCTIONS - For testing only
        function runDemo() {
            // Simulate a journey along the first stage
            let progress = 0;
            
            // Update position every 5 seconds in the demo
            const positionInterval = setInterval(() => {
                if (!routes.stages[0] || progress >= 1) {
                    clearInterval(positionInterval);
                    return;
                }
                
                const points = routes.stages[0].points;
                const pointIndex = Math.floor(progress * (points.length - 1));
                
                // Update the position
                updatePosition(
                    points[pointIndex][0],
                    points[pointIndex][1],
                    new Date().toISOString()
                );
                
                // Move along the route
                progress += 0.05;
                
                // Add a photo occasionally
                if (Math.random() < 0.2) {
                    addPhoto(
                        points[pointIndex][0],
                        points[pointIndex][1],
                        "/api/placeholder/400/300",
                        `Beautiful views from Day 1!`,
                        new Date().toISOString()
                    );
                }
            }, 5000);
        }
        
        // Uncomment to run the demo
        // setTimeout(runDemo, 2000);
    </script>
</body>
</html>
