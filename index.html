<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Jones rides the Hope1000</title>
    <link rel="icon" href="Photos/Hope1000.png" type="image/png">
    <link rel="shortcut icon" href="Photos/Hope1000.png" type="image/png">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://cdn.maptiler.com/maptiler-sdk-js/v3.0.1/maptiler-sdk.umd.min.js"></script>
    <link href="https://cdn.maptiler.com/maptiler-sdk-js/v3.0.1/maptiler-sdk.css" rel="stylesheet" />
    <script src="https://cdn.maptiler.com/leaflet-maptilersdk/v4.0.2/leaflet-maptilersdk.umd.min.js"></script>
    <link rel="stylesheet" href="Styles.css" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/exif-js/2.3.0/exif.min.js"></script>

</head>
<body>
    <div id="container">
        <div id="header">
            <div id="stage-selector">
                <select id="stage-dropdown" class="stage-dropdown">
                    <option value="-1" selected>Whole Trip</option>
                    <option value="0">Stage 1</option>
                    <option value="1">Stage 2</option>
                    <option value="2">Stage 3</option>
                    <option value="3">Stage 4</option>
                    <option value="4">Stage 5</option>
                    <option value="5">Stage 6</option>
                    <option value="6">Stage 7</option>
                    <option value="7">Stage 8</option>
                    <option value="8">Stage 9</option>
                    <option value="9">Stage 10</option>
                    <option value="10">Stage 11</option>
                </select>
            </div>
        </div>
        <div id="map"></div>
        <div id="profileContainer"></div>
        <div id="info-panel">
        </div>

    <div id="photo-modal">
        <span id="close-modal">&times;</span>
        <div id="modal-content">
            <img id="modal-image" src="" alt="Photo">
            <div id="modal-caption"></div>
        </div>
    </div>

    <script>
      // Modify Chart.js loading
      function loadChartJS() {
          return new Promise((resolve, reject) => {
              const chartScript = document.createElement('script');
              chartScript.src = "https://cdn.jsdelivr.net/npm/chart.js";
              chartScript.onload = () => {
                  console.log('Chart.js loaded successfully');
                  resolve();
              };
              chartScript.onerror = reject;
              document.head.appendChild(chartScript);
          });
      }
      // Initialize the (Leaflet) map centered on Switzerland
      const map = L.map('map').setView([46.8182, 8.2275], 8);
      // Maptiler API key
      const key = 'Rx7It18F2RfVcfR5JyxV';
      const mtLayer = L.maptiler.maptilerLayer({
        apiKey: key,
        style: 'https://api.maptiler.com/maps/ch-swisstopo-lbm/style.json', //optional
      }).addTo(map);

    // Redraw chart on window resize
    window.addEventListener('resize', function() {
        const chartElement = document.getElementById('elevationChart');
        if (chartElement) {
            const chart = Chart.getChart(chartElement);
            if (chart) chart.resize();
        }
    });

        // Variables to store trip data
        let currentPosition = null;
        let positionMarker = null;
        let actualPath = [];
        let pathLine = null;
        let photos = [];
        let elevationDataByStage = {};  // Will store elevation data for each stage

        // Stage colors (11 distinct colors)
        const stageColors = [
            '#d73027', // donkerrood
            '#4575b4', // donkerblauw
            '#1a9850', // donkergroen
            '#7b3294', // donkerpaars
            '#e66101', // diep oranje
            '#ffcc00', // donkergeel
            '#a6611a', // warm bruin
            '#d01c8b', // magenta
            '#666666', // donkergrijs
            '#1f968b', // donker teal
            '#f46d43'  // warm koraal
        ];

        // Store all route data
        const routes = {
            stages: [],
            current: 0,
            stravaIds: {}  // Initialize this object early
        };
        
        window.debugStrava = function() {
            console.log("Current routes object:", routes);
            console.log("Registered Strava IDs:", routes.stravaIds);
            console.log("Profile container contents:", document.getElementById('profileContainer').innerHTML);
        };

        // Create a foldable legend
        const legend = L.control({position: 'bottomright'});
        legend.onAdd = function (map) {
            const div = L.DomUtil.create('div', 'legend');
            div.innerHTML = `
                <div class="legend-header">
                    <h4>Legend</h4>
                    <span class="legend-toggle">‚ñº</span>
                </div>
                <div class="legend-content">
                    ${Array.from({length: 11}, (_, i) => `
                        <div class="legend-item">
                            <div class="legend-color" style="background-color: ${stageColors[i]};"></div>
                            <span>Stage ${i+1}</span>
                        </div>
                    `).join('')}
                    <div class="legend-item">
                        <span style="margin-right: 8px;">üö¥‚Äç‚ôÇÔ∏è</span>
                        <span>Current Position</span>
                    </div>
                    <div class="legend-item">
                        <span style="margin-right: 8px;">üì∑</span>
                        <span>Photo</span>
                    </div>
                </div>
            `;
            
            // Add click event to toggle legend
            const toggle = div.querySelector('.legend-toggle');
            const content = div.querySelector('.legend-content');
            
            toggle.addEventListener('click', function() {
                if (content.style.display === 'none') {
                    content.style.display = 'block';
                    toggle.textContent = '‚ñº';
                } else {
                    content.style.display = 'none';
                    toggle.textContent = '‚ñ∂';
                }
            });
            
            return div;
        };
        legend.addTo(map);
        
        // Create a marker for current position (initially hidden)
        const cyclistIcon = L.divIcon({
            html: 'üö¥‚Äç‚ôÇÔ∏è',
            className: 'cyclist-icon',
            iconSize: [30, 30],
            iconAnchor: [15, 15]
        });
        
        positionMarker = L.marker([0, 0], {
            icon: cyclistIcon,
            zIndexOffset: 1000
        });
        
        // Initialize the actual traveled path
        pathLine = L.polyline([], {
            color: '#e63946',
            weight: 5,
            opacity: 0.8
        }).addTo(map);
        
        function isMobileDevice() {
            return window.innerWidth <= 768;
        }

        // Example usage - collapse info panel by default on mobile
        function initializeResponsiveElements() {
            if (isMobileDevice()) {
                document.getElementById('info-panel').classList.add('info-panel-collapsed');
            }
        }

        // Function to parse GPX files
        async function parseGPX(url, stageIndex) {
            try {
                const response = await fetch(url);
                const gpxText = await response.text();
                
                // Parse GPX using DOM parser
                const parser = new DOMParser();
                const gpx = parser.parseFromString(gpxText, "text/xml");
                
                // Extract track points
                const trackPoints = [];
                const points = gpx.getElementsByTagName('trkpt');
                
                for (let i = 0; i < points.length; i++) {
                    const point = points[i];
                    const lat = parseFloat(point.getAttribute('lat'));
                    const lon = parseFloat(point.getAttribute('lon'));
                    
                    // Get elevation if available
                    let ele = 0;
                    const eleNode = point.getElementsByTagName('ele')[0];
                    if (eleNode) {
                        ele = parseFloat(eleNode.textContent);
                    }
                    
                    trackPoints.push([lat, lon, ele]);
                }
                
                // Create route object
                const route = {
                    index: stageIndex,
                    points: trackPoints,
                    distance: calculateRouteDistance(trackPoints),
                    elevation: calculateElevationGain(trackPoints),
                    line: L.polyline(trackPoints.map(p => [p[0], p[1]]), {
                        color: stageColors[stageIndex],
                        weight: 4,
                        opacity: 0.7
                    })
                };
                
                // Add to routes collection
                routes.stages[stageIndex] = route;
                
                // Add to map and fit bounds
                route.line.addTo(map);
                
                // Add start and end markers
                if (trackPoints.length > 0) {
                    const startPoint = trackPoints[0];
                    const endPoint = trackPoints[trackPoints.length - 1];
                    
                    L.marker([startPoint[0], startPoint[1]], {
                        title: `Stage ${stageIndex + 1} Start`,
                        icon: L.icon({
                            iconUrl: 'https://unpkg.com/leaflet@1.9.4/dist/images/marker-icon.png',
                            iconSize: [15, 25], // Reduce from default [25, 41] to smaller size
                            iconAnchor: [7, 25], // Adjust anchor point accordingly
                            popupAnchor: [1, -22] // Adjust popup anchor accordingly
                        })
                    }).addTo(map)
                    .bindPopup(`<strong>Stage ${stageIndex + 1} Start</strong>`);
                    
                    L.marker([endPoint[0], endPoint[1]], {
                        title: `Stage ${stageIndex + 1} End`,
                        icon: L.icon({
                            iconUrl: 'https://unpkg.com/leaflet@1.9.4/dist/images/marker-icon.png',
                            iconSize: [15, 25], // Reduce from default [25, 41] to smaller size
                            iconAnchor: [7, 25], // Adjust anchor point accordingly
                            popupAnchor: [1, -22] // Adjust popup anchor accordingly
                        })
                    }).addTo(map)
                    .bindPopup(`<strong>Stage ${stageIndex + 1} End</strong>`);
                }
                
                return route;
            } catch (error) {
                console.error(`Error loading GPX for stage ${stageIndex + 1}:`, error);
                return null;
            }
        }
        
        // Calculate distance of a route
        function calculateRouteDistance(points) {
            let distance = 0;
            for (let i = 1; i < points.length; i++) {
                const prevPoint = L.latLng(points[i-1][0], points[i-1][1]);
                const currPoint = L.latLng(points[i][0], points[i][1]);
                distance += prevPoint.distanceTo(currPoint);
            }
            return distance / 1000; // Convert to kilometers
        }
        
        // Calculate elevation gain
        function calculateElevationGain(points) {
            let gain = 0;
            for (let i = 1; i < points.length; i++) {
                const elevDiff = points[i][2] - points[i-1][2];
                if (elevDiff > 0) {
                    gain += elevDiff;
                }
            }
            return gain;
        }
        
        // Function to handle stage dropdown change
        function handleStageChange() {
            const dropdown = document.getElementById('stage-dropdown');
            const selectedValue = parseInt(dropdown.value);
            
            if (selectedValue === -1) {
                // Whole trip selected - show all stages and fit all bounds
                showWholeTrip();
            } else {
                // Individual stage selected
                focusOnStage(selectedValue);
                createElevationProfile(selectedValue);
            }
        }
        
        // Function to show the whole trip
        function showWholeTrip() {
            // Zoom to fit all routes
            const bounds = [];
            let totalDistance = 0;
            let totalElevation = 0;
            
            for (let i = 0; i < routes.stages.length; i++) {
                if (routes.stages[i]) {
                    const stage = routes.stages[i];
                    const stagePoints = stage.points.map(p => [p[0], p[1]]);
                    bounds.push(...stagePoints);
                    
                    // Sum up stats
                    totalDistance += stage.distance;
                    totalElevation += stage.elevation;
                }
            }
            
            if (bounds.length > 0) {
                map.fitBounds(bounds.map(p => L.latLng(p[0], p[1])));
                
                // Update display
                document.getElementById('current-stage').textContent = `All`;
                document.getElementById('distance-traveled').textContent = totalDistance.toFixed(1);
                document.getElementById('elevation-gain').textContent = totalElevation.toFixed(0);
            } else {
                // Fallback to Switzerland view if no routes loaded
                map.setView([46.8182, 8.2275], 8);
            }
            
            // Clear elevation profile when showing whole trip
            const profileContainer = document.getElementById('profileContainer');
            profileContainer.innerHTML = '';
        }
        
        // Focus on a specific stage
        function focusOnStage(stageIndex) {
            console.log(`Focusing on stage ${stageIndex}`);
            
            if (routes.stages[stageIndex]) {
                const route = routes.stages[stageIndex];
                map.fitBounds(route.line.getBounds());
                
                // Update displays
                document.getElementById('current-stage').textContent = `${stageIndex + 1}/11`;
                document.getElementById('elevation-gain').textContent = route.elevation.toFixed(0);
                document.getElementById('distance-traveled').textContent = route.distance.toFixed(1);
                
                // Clear the profile container completely
                const profileContainer = document.getElementById('profileContainer');
                profileContainer.innerHTML = '';
                
                // Explicitly log what we're checking for
                console.log(`Looking for Strava ID for stage ${stageIndex}:`, routes.stravaIds[stageIndex]);
                
                // Check if we have a Strava ID for this stage
                if (routes.stravaIds && routes.stravaIds[stageIndex]) {
                    console.log(`Found Strava ID ${routes.stravaIds[stageIndex]} for stage ${stageIndex + 1}`);
                    // Use a setTimeout to ensure DOM is ready
                    setTimeout(() => {
                        embedStravaActivity(stageIndex, routes.stravaIds[stageIndex]);
                    }, 100);
                } else {
                    console.log(`No Strava ID found for stage ${stageIndex + 1}, showing elevation profile`);
                    createElevationProfile(stageIndex);
                }
            }
        }


        // Helper function to extract location from image
        async function extractLocationFromImage(file) {
        return new Promise((resolve) => {
            const reader = new FileReader();
            
            reader.onload = function(e) {
            const exif = EXIF.readFromBinaryFile(e.target.result);
            
            if (exif && exif.GPSLatitude && exif.GPSLongitude) {
                // Convert GPS coordinates to decimal degrees
                const lat = convertDMSToDD(exif.GPSLatitude, exif.GPSLatitudeRef);
                const lon = convertDMSToDD(exif.GPSLongitude, exif.GPSLongitudeRef);
                
                resolve({ lat, lon });
            } else {
                resolve(null);
            }
            };
            
            reader.readAsArrayBuffer(file);
        });
        }

        // Function to update position from Spot Gen4
        function updatePosition(lat, lon, timestamp) {
            if (!currentPosition) {
                positionMarker.setLatLng([lat, lon]).addTo(map);
            } else {
                positionMarker.setLatLng([lat, lon]);
            }
            
            currentPosition = [lat, lon];
            actualPath.push(currentPosition);
            
            // Update actual path line
            if (!pathLine) {
                pathLine = L.polyline(actualPath, {
                    color: '#e63946',
                    weight: 5,
                    opacity: 0.8
                }).addTo(map);
            } else {
                pathLine.setLatLngs(actualPath);
            }
            
            // Update last update time
            const updateTime = new Date(timestamp);
            document.getElementById('last-update').textContent = 
                'Last updated: ' + updateTime.toLocaleString();
            
            // Determine current stage based on position
            determineCurrentStage(lat, lon);
            
            // Also update position on elevation profile if we're looking at a specific stage
            updatePositionOnElevationProfile(lat, lon);
        }       
        // Determine which stage the cyclist is currently on
        function determineCurrentStage(lat, lon) {
            const position = L.latLng(lat, lon);
            let closestStage = 0;
            let closestDistance = Infinity;
            
            for (let i = 0; i < routes.stages.length; i++) {
                if (routes.stages[i]) {
                    const stage = routes.stages[i];
                    const routePoints = stage.points.map(p => L.latLng(p[0], p[1]));
                    
                    // Find closest point on this route
                    let minDistance = Infinity;
                    for (const point of routePoints) {
                        const distance = position.distanceTo(point);
                        if (distance < minDistance) {
                            minDistance = distance;
                        }
                    }
                    
                    if (minDistance < closestDistance) {
                        closestDistance = minDistance;
                        closestStage = i;
                    }
                }
            }
            
            // Update current stage if it changed
            if (routes.current !== closestStage) {
                routes.current = closestStage;
                
                // Update dropdown to reflect current stage
                document.getElementById('stage-dropdown').value = closestStage.toString();
                
                // Update stats display
                document.getElementById('current-stage').textContent = `${closestStage + 1}/11`;
                
                if (routes.stages[closestStage]) {
                    document.getElementById('elevation-gain').textContent = 
                        routes.stages[closestStage].elevation.toFixed(0);
                    document.getElementById('distance-traveled').textContent = 
                        routes.stages[closestStage].distance.toFixed(1);
                }
            }
        }
        
        // Function to add a photo
        function addPhoto(lat, lon, imageUrl, caption, timestamp) {
            // Create a photo object
            const photo = {
                position: [lat, lon],
                imageUrl: imageUrl,
                caption: caption,
                timestamp: timestamp
            };
            
            photos.push(photo);
            
            // Add photo marker to map
            const photoMarker = L.marker([lat, lon], {
                icon: L.divIcon({
                    html: 'üì∑',
                    className: 'photo-icon',
                    iconSize: [30, 30],
                    iconAnchor: [15, 15]
                })
            }).addTo(map);
            
            // Create popup with photo
            const popupContent = `
                <div class="photo-popup">
                    <img src="${imageUrl}" class="popup-image" alt="Photo">
                    <div>${caption}</div>
                    <div class="popup-time">${new Date(timestamp).toLocaleString()}</div>
                </div>
            `;
            
            photoMarker.bindPopup(popupContent, {
                className: 'custom-popup',
                maxWidth: 250
            });
            
            // Add to gallery
            const gallery = document.getElementById('photo-gallery');
            const thumbnail = document.createElement('img');
            thumbnail.src = imageUrl;
            thumbnail.className = 'photo-thumbnail';
            thumbnail.setAttribute('data-index', photos.length - 1);
            thumbnail.addEventListener('click', function() {
                openPhotoModal(parseInt(this.getAttribute('data-index')));
            });
            
            gallery.appendChild(thumbnail);
            
            // Update photo count
            document.getElementById('photos-shared').textContent = photos.length;
        }
        
        // Function to open the photo modal
        function openPhotoModal(index) {
            const photo = photos[index];
            document.getElementById('modal-image').src = photo.imageUrl;
            document.getElementById('modal-caption').textContent = 
                photo.caption + ' - ' + new Date(photo.timestamp).toLocaleString();
            document.getElementById('photo-modal').style.display = 'flex';
        }
        
        // Function to close the photo modal
        document.getElementById('close-modal').addEventListener('click', function() {
            document.getElementById('photo-modal').style.display = 'none';
        });


        // Function to create elevation profile for a stage
        function createElevationProfile(stageIndex) {
            if (!routes.stages[stageIndex]) return;
            
            const profileContainer = document.getElementById('profileContainer');
            profileContainer.innerHTML = '';
            
            // Create canvas for the chart
            const canvas = document.createElement('canvas');
            canvas.id = 'elevationChart';
            profileContainer.appendChild(canvas);
            
            // Extract elevation data from stage
            const stage = routes.stages[stageIndex];
            const elevationData = stage.points.map((point, index) => {
                // Calculate distance from start for each point
                let distanceFromStart = 0;
                if (index > 0) {
                    for (let i = 1; i <= index; i++) {
                        const prevPoint = L.latLng(stage.points[i-1][0], stage.points[i-1][1]);
                        const currPoint = L.latLng(stage.points[i][0], stage.points[i][1]);
                        distanceFromStart += prevPoint.distanceTo(currPoint);
                    }
                }
                
                return {
                    distance: distanceFromStart / 1000, // km
                    elevation: point[2],
                    lat: point[0],
                    lon: point[1],
                    index: index
                };
            });
            
            // Store elevation data globally for this stage
            elevationDataByStage[stageIndex] = elevationData;

            // Create position marker for hovering
            const hoverMarker = L.circleMarker([0, 0], {
                radius: 8,
                color: '#ff0000',
                fillColor: '#ff0000',
                fillOpacity: 0.5,
                weight: 2
            });
            
            // Create chart
            if (window.Chart) {
                const ctx = document.getElementById('elevationChart').getContext('2d');
                const chart = new Chart(ctx, {
                    type: 'line',
                    data: {
                        datasets: [{
                            label: `Elevation Profile - Stage ${stageIndex + 1}`,
                            data: elevationData,
                            borderColor: stageColors[stageIndex],
                            backgroundColor: `${stageColors[stageIndex]}80`,
                            borderWidth: 2,
                            pointRadius: 0,
                            fill: true // Enable fill under the line
                        }]
                    },
                    // Inside the createElevationProfile function, modify the options section of the Chart configuration:
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        parsing: {
                            xAxisKey: 'distance',
                            yAxisKey: 'elevation'
                        },
                        scales: {
                            x: {
                                type: 'linear',
                                title: {
                                    display: true,
                                    text: 'Distance (km)'
                                }
                            },
                            y: {
                                title: {
                                    display: true,
                                    text: 'Elevation (m)'
                                }
                            }
                        },
                        plugins: {
                            legend: {
                                display: false // Hide the legend
                            },
                            title: {
                                display: true,
                                text: `Elevation Profile - Stage ${stageIndex + 1}`
                            },
                            tooltip: {
                                mode: 'index',
                                intersect: false,
                                displayColors: false, // This removes the colored box
                                callbacks: {
                                    title: function(context) {
                                    return `Distance: ${context[0].raw.distance.toFixed(1)} km\nElevation: ${context[0].raw.elevation.toFixed(0)} m`;
                                    },
                                    label: function(context) {
                                    return ``;
                                    }
                                }
                            }
                        },
                        interaction: {
                            mode: 'index',
                            intersect: false
                        }
                    }
                });
                            
                // Add mouse event listeners to handle hover
                canvas.addEventListener('mousemove', function(event) {
                    const points = chart.getElementsAtEventForMode(event, 'index', { intersect: false });
                    if (points.length > 0) {
                        const dataIndex = points[0].index;
                        const pointData = elevationData[dataIndex];
                        
                        // Update marker position
                        hoverMarker.setLatLng([pointData.lat, pointData.lon]);
                        
                        // Add marker to map if not already added
                        if (!map.hasLayer(hoverMarker)) {
                            hoverMarker.addTo(map);
                        }
                    }
                });
                            
                // Remove marker when mouse leaves the chart
                canvas.addEventListener('mouseout', function() {
                    if (map.hasLayer(hoverMarker)) {
                        map.removeLayer(hoverMarker);
                    }
                });
            }
        }
        // Add this function to your code
        function updatePositionOnElevationProfile(lat, lon) {
            // Get the current stage
            const currentStage = routes.current;
            if (currentStage === -1) return; // No specific stage selected
            
            // Check if we have elevation data for this stage
            if (!elevationDataByStage[currentStage]) return;
            
            // Get the chart
            const chartElement = document.getElementById('elevationChart');
            if (!chartElement) return;
            
            const chart = Chart.getChart(chartElement);
            if (!chart) return;
            
            // Find closest point on the route to the current position
            const currentPoint = L.latLng(lat, lon);
            const stagePoints = routes.stages[currentStage].points;
            let closestIndex = 0;
            let minDistance = Infinity;
            
            for (let i = 0; i < stagePoints.length; i++) {
                const routePoint = L.latLng(stagePoints[i][0], stagePoints[i][1]);
                const distance = currentPoint.distanceTo(routePoint);
                if (distance < minDistance) {
                    minDistance = distance;
                    closestIndex = i;
                }
            }
            
            const positionData = elevationDataByStage[currentStage][closestIndex];
            
            // Check if we already have a position dataset
            if (chart.data.datasets.length < 2) {
                // Add new dataset for current position
                chart.data.datasets.push({
                    label: 'Current Position',
                    data: [{
                        distance: positionData.distance,
                        elevation: positionData.elevation
                    }],
                    borderColor: '#ff0000',
                    backgroundColor: '#ff0000',
                    borderWidth: 0,
                    pointRadius: 8,
                    pointHoverRadius: 10,
                    pointStyle: 'circle',
                    fill: false,
                    showLine: false
                });
            } else {
                // Update existing position dataset
                chart.data.datasets[1].data = [{
                    distance: positionData.distance,
                    elevation: positionData.elevation
                }];
            }
            
            chart.update();
            console.log(`Updated position on elevation profile: ${positionData.distance.toFixed(1)}km, ${positionData.elevation.toFixed(0)}m`);
        }
        // Load GPX files - replace these URLs with your actual GPX files
        async function loadGPXFiles() {
            // Add event listener for dropdown
            document.getElementById('stage-dropdown').addEventListener('change', handleStageChange);
            
            // Load stages
            parseGPX('https://raw.githubusercontent.com/JonathanBurez/JonathanBurez.github.io/refs/heads/main/Day01.gpx', 0);
            parseGPX('https://raw.githubusercontent.com/JonathanBurez/JonathanBurez.github.io/refs/heads/main/Day02.gpx', 1);
            parseGPX('https://raw.githubusercontent.com/JonathanBurez/JonathanBurez.github.io/refs/heads/main/Day03.gpx', 2);
            parseGPX('https://raw.githubusercontent.com/JonathanBurez/JonathanBurez.github.io/refs/heads/main/Day04.gpx', 3);
            parseGPX('https://raw.githubusercontent.com/JonathanBurez/JonathanBurez.github.io/refs/heads/main/Day05.gpx', 4);
            parseGPX('https://raw.githubusercontent.com/JonathanBurez/JonathanBurez.github.io/refs/heads/main/Day06.gpx', 5);
            parseGPX('https://raw.githubusercontent.com/JonathanBurez/JonathanBurez.github.io/refs/heads/main/Day07.gpx', 6);
            parseGPX('https://raw.githubusercontent.com/JonathanBurez/JonathanBurez.github.io/refs/heads/main/Day08.gpx', 7);
            parseGPX('https://raw.githubusercontent.com/JonathanBurez/JonathanBurez.github.io/refs/heads/main/Day09.gpx', 8);
            parseGPX('https://raw.githubusercontent.com/JonathanBurez/JonathanBurez.github.io/refs/heads/main/Day10.gpx', 9);
            parseGPX('https://raw.githubusercontent.com/JonathanBurez/JonathanBurez.github.io/refs/heads/main/Day11.gpx', 10);
            
            // Initialize with whole trip view
            setTimeout(showWholeTrip, 1000);
        }
        
        // Function to fetch spot data
        async function fetchSpotData() {
            try {
                // Replace with your actual Spot API endpoint and parameters
                const feedId = "YOUR_FEED_ID";  // Your Spot Gen4 feed ID
                const apiKey = "YOUR_API_KEY";  // Your API key if required
                
                const response = await fetch(`https://api.findmespot.com/spot-main-web/consumer/rest-api/2.0/public/feed/${feedId}/message.json?apiKey=${apiKey}`);
                
                if (!response.ok) {
                    throw new Error(`API responded with status: ${response.status}`);
                }
                
                const data = await response.json();
                
                // Process Spot data - this structure may need adjustment based on actual Spot API response
                if (data && data.response && data.response.feedMessageResponse && 
                    data.response.feedMessageResponse.messages && 
                    data.response.feedMessageResponse.messages.length > 0) {
                    
                    const latestMessage = data.response.feedMessageResponse.messages[0];
                    
                    // Update position with the latest coordinates
                    updatePosition(
                        latestMessage.latitude,
                        latestMessage.longitude,
                        latestMessage.dateTime
                    );
                    
                    console.log(`Position updated: ${latestMessage.latitude}, ${latestMessage.longitude}`);
                } else {
                    console.log("No messages found in Spot data");
                }
            } catch (error) {
                console.error('Error fetching Spot data:', error);
            }
        }

 
        function addTestPhoto() {
    // Add your photo URLs here in the future
    const photoUrls = [
        "https://www.dropbox.com/scl/fi/jyef6ze37gm9r2m9pmri0/2025-04-02_14-30-00_46.8182_8.2275.jpg?rlkey=we8t71l4asqc785cr7ryq57qb&st=s59vpnfn&raw=1",
        "https://www.dropbox.com/scl/fi/8f104bedi9f09blz6zml2/2025-04-08_19-28-00_50.83018_3.62887.jpg?rlkey=0eap4gmcnocfxmab0aogudjck&st=cvok7h28&raw=1",
        "https://www.dropbox.com/scl/fi/vq5iqkyai8pqg1l869puf/2025-04-08_20-00-00_47.5827695_9.2663696.jpg?rlkey=brgbvfsfcpyvgf3shtwho0o5w&st=yjdi0pom&raw=1"
        // Add more URLs here when needed
    ];

    // Process each photo
    photoUrls.forEach((url, index) => {
        // Extract metadata from filename
        const metadata = extractMetadataFromUrl(url);
        console.log(`Adding photo ${index+1} at coordinates: ${metadata.lat}, ${metadata.lon}`);
        
        // Add to map with extracted metadata
        addPhoto(
            metadata.lat,
            metadata.lon,
            url,
            metadata.caption,
            metadata.timestamp
        );
    });
    
    // If no photos in the list, use a placeholder
    if (photoUrls.length === 0) {
        console.log("No photos in list, using placeholder");
        addPhoto(46.8182, 8.2275, "/api/placeholder/400/300", "Placeholder Image", new Date().toISOString());
    }
}

// Helper function to extract metadata from URL
function extractMetadataFromUrl(url) {
    // Parse the filename from the URL
    const filename = url.split('/').pop().split('?')[0];
    let lat = 46.8182; // Default coordinates
    let lon = 8.2275;
    let timestamp = new Date().toISOString();
    
    // Try to extract data from filename
    // Expected format: YYYY-MM-DD_HH-MM-SS_LAT_LON.jpg
    const parts = filename.split('_');
    if (parts.length >= 4) {
        // Extract date and time
        const dateStr = parts[0];
        const timeStr = parts[1].replace(/-/g, ':');
        
        // Extract coordinates
        try {
            lat = parseFloat(parts[2]);
            // Extract longitude, preserving decimal points but removing file extension
            const lonPart = parts[3];
            // Find where the file extension starts (after last period)
            const lastDotIndex = lonPart.lastIndexOf('.');
            // If there's a file extension, remove it, otherwise use the whole string
            lon = parseFloat(lastDotIndex > 0 ? lonPart.substring(0, lastDotIndex) : lonPart);            

            // Create timestamp
            const dateParts = dateStr.split('-');
            const timeParts = timeStr.split(':');
            const dateObj = new Date(
                parseInt(dateParts[0]), 
                parseInt(dateParts[1]) - 1, // Month is 0-indexed
                parseInt(dateParts[2]), 
                parseInt(timeParts[0]), 
                parseInt(timeParts[1]), 
                parseInt(timeParts[2] || 0)
            );
            timestamp = dateObj.toISOString();
        } catch (e) {
            console.warn("Could not parse coordinates or timestamp from filename:", e);
        }
    }
    
    return {
        lat: lat,
        lon: lon,
        timestamp: timestamp,
        caption: `Photo taken on ${new Date(timestamp).toLocaleDateString()} at ${new Date(timestamp).toLocaleTimeString()}`
    };
}

// Add this function to fetch weather data
async function fetchWeather(lat, lon) {
    try {
        // Using OpenWeatherMap API - you'll need to get your own API key
        const apiKey = '7ec6fc23b8c09598e1faa2a4e81ea271'; // Replace with your API key
        const response = await fetch(`https://api.openweathermap.org/data/2.5/weather?lat=${lat}&lon=${lon}&units=metric&appid=${apiKey}`);
        
        if (!response.ok) {
            throw new Error('Weather data not available');
        }
        
        const data = await response.json();
        return data;
    } catch (error) {
        console.error('Error fetching weather:', error);
        return null;
    }
}

// Add this function to update the weather widget
function updateWeatherWidget(weatherData) {
    const weatherContainer = document.getElementById('weather-widget');
    
    if (!weatherData) {
        weatherContainer.innerHTML = '<div class="weather-error">Weather data unavailable</div>';
        return;
    }
    
    // Get weather icon
    const iconCode = weatherData.weather[0].icon;
    const iconUrl = `https://openweathermap.org/img/wn/${iconCode}@2x.png`;
    
    // Format weather info
    weatherContainer.innerHTML = `
        <div class="weather-content">
            <div class="weather-icon">
                <img src="${iconUrl}" alt="${weatherData.weather[0].description}">
            </div>
            <div class="weather-info">
                <div class="weather-temp">${Math.round(weatherData.main.temp)}¬∞C</div>
                <div class="weather-desc">${weatherData.weather[0].description}</div>
                <div class="weather-location">${weatherData.name}</div>
            </div>
        </div>
    `;
}
function registerStravaActivities() {
    // Clear any existing registrations
    routes.stravaIds = {};
    
    // Register known Strava activities
    registerStravaActivity(0, '14163389019'); // Stage 1
    // registerStravaActivity(1, '2345678901'); // Stage 2
    // registerStravaActivity(2, '2345678901'); // Stage 3
    // registerStravaActivity(3, '2345678901'); // Stage 4
    // registerStravaActivity(4, '2345678901'); // Stage 5
    // registerStravaActivity(5, '2345678901'); // Stage 6
    // registerStravaActivity(6, '2345678901'); // Stage 7
    // registerStravaActivity(7, '2345678901'); // Stage 8
    // registerStravaActivity(8, '2345678901'); // Stage 9
    // registerStravaActivity(9, '2345678901'); // Stage 10
    // registerStravaActivity(10, '2345678901'); // Stage 11
    console.log("Strava activities registered:", routes.stravaIds);
}

function registerStravaActivity(stageIndex, stravaId) {
    if (!routes.stravaIds) routes.stravaIds = {};
    routes.stravaIds[stageIndex] = stravaId;
    console.log(`Registered Strava activity ${stravaId} for stage ${stageIndex + 1}`);
}

// Add this function to get current weather
async function getCurrentWeather() {
    let lat, lon;
    
    // Use current position if available
    if (currentPosition) {
        [lat, lon] = currentPosition;
    } 
    // Use last point from actualPath if available
    else if (actualPath.length > 0) {
        const lastPoint = actualPath[actualPath.length - 1];
        [lat, lon] = lastPoint;
    } 
    // Default to Romanshorn
    else {
        lat = 47.5663267;
        lon = 9.3836637;
    }
    
    const weatherData = await fetchWeather(lat, lon);
    updateWeatherWidget(weatherData);
}

function embedStravaActivity(stageIndex, stravaId) {
    console.log(`Adding Strava activity link for stage ${stageIndex + 1}`);
    
    // Get the profile container
    const profileContainer = document.getElementById('profileContainer');
    
    // Clear existing content
    profileContainer.innerHTML = '';
    
    // Create a nice-looking link/button to the activity
    const stravaLink = document.createElement('div');
    stravaLink.className = 'strava-activity-link';
    stravaLink.innerHTML = `
        <div class="strava-fallback">
            <img src="https://cdn.iconscout.com/icon/free/png-256/free-strava-3772409-3147400.png" 
                 alt="Strava Logo" class="strava-logo">
            <p>View detailed activity data for Stage ${stageIndex + 1} on Strava</p>
            <a href="https://www.strava.com/activities/${stravaId}" target="_blank" class="strava-button">
                Open Activity
            </a>
        </div>
    `;
    
    profileContainer.appendChild(stravaLink);
}

function checkStravaStatus() {
    console.log("Current routes object:", routes);
    console.log("Registered Strava IDs:", routes.stravaIds);
}

// Modify initialization to wait for Chart.js
async function initApp() {
    // Register Strava activities
    registerStravaActivities();
    checkStravaStatus();
    
    // First load Chart.js
    await loadChartJS();

    // Then load GPX routes
    await loadGPXFiles();

    // Add the info panel header and toggle functionality
    const infoPanel = document.getElementById('info-panel');
    const infoPanelContent = infoPanel.innerHTML;
    
    // Wrap existing content in the panel content div
    infoPanel.innerHTML = `
        <div class="info-panel-header">
            <h3 class="info-panel-title">Trip Information</h3>
            <span class="info-panel-toggle">‚ñº</span>
        </div>
        <div class="info-panel-content">
                  <div id="trip-stats">
                      <div class="stat-box">
                          <div class="stat-value" id="current-stage">0/11</div>
                          <div class="stat-label">Current Stage</div>
                      </div>
                      <div class="stat-box">
                          <div class="stat-value" id="distance-traveled">0</div>
                          <div class="stat-label">Kilometers</div>
                      </div>
                      <div class="stat-box">
                          <div class="stat-value" id="elevation-gain">0</div>
                          <div class="stat-label">Meters Climbed</div>
                      </div>
                      <div class="stat-box">
                          <div class="stat-value" id="photos-shared">0</div>
                          <div class="stat-label">Photos Shared</div>
                      </div>
                  </div>
                  <div id="weather-widget">
                    <div class="weather-content">
                        <div class="weather-icon">
                            <img src="Photos/Hope1000.png" alt="Weather">
                        </div>
                        <div class="weather-info">
                            <div class="weather-temp">--¬∞C</div>
                            <div class="weather-desc">Loading weather...</div>
                            <div class="weather-location">--</div>
                        </div>
                    </div>
                </div>
                  <h2>Latest Photos</h2>
                  <div id="photo-gallery">
                      <!-- Photos will be added here dynamically -->
                  </div>
                  <div id="last-update">Last updated: Not yet started</div>
        </div>
    `;
    // Inside the initApp function, after setting the infoPanel.innerHTML, add this line:
    infoPanel.classList.add('info-panel-collapsed');

    // And change the toggle text:
    const toggle = document.querySelector('.info-panel-toggle');
    toggle.textContent = '‚ñ≤';
    // Add event listener for toggle
    document.querySelector('.info-panel-header').addEventListener('click', function() {
        const panel = document.getElementById('info-panel');
        panel.classList.toggle('info-panel-collapsed');
        
        const toggle = document.querySelector('.info-panel-toggle');
        if (panel.classList.contains('info-panel-collapsed')) {
            toggle.textContent = '‚ñ≤';
        } else {
            toggle.textContent = '‚ñº';
        }
    });

    // Add this to your initApp function
    function optimizeForTouch() {
        if ('ontouchstart' in window) {
            // Increase popup size for touch devices
            map.options.tapTolerance = 30;
            
            // Increase marker size for easier tapping
            const markerElements = document.querySelectorAll('.leaflet-marker-icon');
            markerElements.forEach(marker => {
                marker.style.width = '30px';
                marker.style.height = '30px';
            });
        }
    }

    addTestPhoto();
    // Add this at the end of the initApp function:
    getCurrentWeather();
    // Update weather every 30 minutes
    setInterval(getCurrentWeather, 30 * 60 * 1000);
    // Initial fetch
    fetchSpotData();

    // Then fetch every 5 minutes (adjust timing as needed)
    const updateInterval = 5 * 60 * 1000; // 5 minutes in milliseconds
    setInterval(fetchSpotData, updateInterval);

    console.log(`Position updates scheduled every ${updateInterval/60000} minutes`);
}
        
        // Start the application
        initApp();
        
        // DEMO FUNCTIONS - For testing only
        function runDemo() {
            // Simulate a journey along the first stage
            let progress = 0;
            
            // Update position every 5 seconds in the demo
            const positionInterval = setInterval(() => {
                if (!routes.stages[0] || progress >= 1) {
                    clearInterval(positionInterval);
                    return;
                }
                
                const points = routes.stages[0].points;
                const pointIndex = Math.floor(progress * (points.length - 1));
                
                // Update the position
                updatePosition(
                    points[pointIndex][0],
                    points[pointIndex][1],
                    new Date().toISOString()
                );
                
                // Move along the route
                progress += 0.05;
                
                // Add a photo occasionally
                if (Math.random() < 0.2) {
                    addPhoto(
                        points[pointIndex][0],
                        points[pointIndex][1],
                        "/api/placeholder/400/300",
                        `Beautiful views from Day 1!`,
                        new Date().toISOString()
                    );
                }
            }, 5000);
        }
        
        // Uncomment to run the demo
        // setTimeout(runDemo, 2000);
    </script>
</body>
</html>
