<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Switzerland Cycling Adventure Tracker</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://cdn.maptiler.com/maptiler-sdk-js/v3.0.1/maptiler-sdk.umd.min.js"></script>
    <link href="https://cdn.maptiler.com/maptiler-sdk-js/v3.0.1/maptiler-sdk.css" rel="stylesheet" />
    <script src="https://cdn.maptiler.com/leaflet-maptilersdk/v4.0.2/leaflet-maptilersdk.umd.min.js"></script>
    <link rel="stylesheet" href="Styles.css" />
</head>
<body>
    <div id="container">
        <div id="header">
            <div id="stage-selector">
                <select id="stage-dropdown" class="stage-dropdown">
                    <option value="-1" selected>Whole Trip</option>
                    <option value="0">Stage 1</option>
                    <option value="1">Stage 2</option>
                    <option value="2">Stage 3</option>
                    <option value="3">Stage 4</option>
                    <option value="4">Stage 5</option>
                    <option value="5">Stage 6</option>
                    <option value="6">Stage 7</option>
                    <option value="7">Stage 8</option>
                    <option value="8">Stage 9</option>
                    <option value="9">Stage 10</option>
                    <option value="10">Stage 11</option>
                </select>
            </div>
        </div>
        <div id="map"></div>
        <div id="profileContainer"></div>
        <div id="info-panel">
          document.getElementById('info-panel').innerHTML = `
              <div class="info-panel-header">
                  <h3 class="info-panel-title">Trip Information</h3>
                  <span class="info-panel-toggle">‚ñº</span>
              </div>
              <div class="info-panel-content">
              </div>
          `;
        </div>

    <div id="photo-modal">
        <span id="close-modal">&times;</span>
        <div id="modal-content">
            <img id="modal-image" src="" alt="Photo">
            <div id="modal-caption"></div>
        </div>
    </div>

    <script>
      // Modify Chart.js loading
      function loadChartJS() {
          return new Promise((resolve, reject) => {
              const chartScript = document.createElement('script');
              chartScript.src = "https://cdn.jsdelivr.net/npm/chart.js";
              chartScript.onload = () => {
                  console.log('Chart.js loaded successfully');
                  resolve();
              };
              chartScript.onerror = reject;
              document.head.appendChild(chartScript);
          });
      }
      // Initialize the (Leaflet) map centered on Switzerland
      const map = L.map('map').setView([46.8182, 8.2275], 8);
      // Maptiler API key
      const key = 'Rx7It18F2RfVcfR5JyxV';
      const mtLayer = L.maptiler.maptilerLayer({
        apiKey: key,
        style: 'https://api.maptiler.com/maps/ch-swisstopo-lbm/style.json', //optional
      }).addTo(map);

        // Variables to store trip data
        let currentPosition = null;
        let positionMarker = null;
        let actualPath = [];
        let pathLine = null;
        let photos = [];
        
        // Stage colors (11 distinct colors)
        const stageColors = [
            '#d73027', // donkerrood
            '#4575b4', // donkerblauw
            '#1a9850', // donkergroen
            '#7b3294', // donkerpaars
            '#e66101', // diep oranje
            '#ffcc00', // donkergeel
            '#a6611a', // warm bruin
            '#d01c8b', // magenta
            '#666666', // donkergrijs
            '#1f968b', // donker teal
            '#f46d43'  // warm koraal
        ];
        
        // Store all route data
        const routes = {
            stages: [],
            current: 0
        };
        
        // Create a foldable legend
        const legend = L.control({position: 'bottomright'});
        legend.onAdd = function (map) {
            const div = L.DomUtil.create('div', 'legend');
            div.innerHTML = `
                <div class="legend-header">
                    <h4>Legend</h4>
                    <span class="legend-toggle">‚ñº</span>
                </div>
                <div class="legend-content">
                    ${Array.from({length: 11}, (_, i) => `
                        <div class="legend-item">
                            <div class="legend-color" style="background-color: ${stageColors[i]};"></div>
                            <span>Stage ${i+1}</span>
                        </div>
                    `).join('')}
                    <div class="legend-item">
                        <span style="margin-right: 8px;">üö¥‚Äç‚ôÇÔ∏è</span>
                        <span>Current Position</span>
                    </div>
                    <div class="legend-item">
                        <span style="margin-right: 8px;">üì∑</span>
                        <span>Photo</span>
                    </div>
                </div>
            `;
            
            // Add click event to toggle legend
            const toggle = div.querySelector('.legend-toggle');
            const content = div.querySelector('.legend-content');
            
            toggle.addEventListener('click', function() {
                if (content.style.display === 'none') {
                    content.style.display = 'block';
                    toggle.textContent = '‚ñº';
                } else {
                    content.style.display = 'none';
                    toggle.textContent = '‚ñ∂';
                }
            });
            
            return div;
        };
        legend.addTo(map);
        
        // Create a marker for current position (initially hidden)
        const cyclistIcon = L.divIcon({
            html: 'üö¥‚Äç‚ôÇÔ∏è',
            className: 'cyclist-icon',
            iconSize: [30, 30],
            iconAnchor: [15, 15]
        });
        
        positionMarker = L.marker([0, 0], {
            icon: cyclistIcon,
            zIndexOffset: 1000
        });
        
        // Initialize the actual traveled path
        pathLine = L.polyline([], {
            color: '#e63946',
            weight: 5,
            opacity: 0.8
        }).addTo(map);
        
        // Function to parse GPX files
        async function parseGPX(url, stageIndex) {
            try {
                const response = await fetch(url);
                const gpxText = await response.text();
                
                // Parse GPX using DOM parser
                const parser = new DOMParser();
                const gpx = parser.parseFromString(gpxText, "text/xml");
                
                // Extract track points
                const trackPoints = [];
                const points = gpx.getElementsByTagName('trkpt');
                
                for (let i = 0; i < points.length; i++) {
                    const point = points[i];
                    const lat = parseFloat(point.getAttribute('lat'));
                    const lon = parseFloat(point.getAttribute('lon'));
                    
                    // Get elevation if available
                    let ele = 0;
                    const eleNode = point.getElementsByTagName('ele')[0];
                    if (eleNode) {
                        ele = parseFloat(eleNode.textContent);
                    }
                    
                    trackPoints.push([lat, lon, ele]);
                }
                
                // Create route object
                const route = {
                    index: stageIndex,
                    points: trackPoints,
                    distance: calculateRouteDistance(trackPoints),
                    elevation: calculateElevationGain(trackPoints),
                    line: L.polyline(trackPoints.map(p => [p[0], p[1]]), {
                        color: stageColors[stageIndex],
                        weight: 4,
                        opacity: 0.7
                    })
                };
                
                // Add to routes collection
                routes.stages[stageIndex] = route;
                
                // Add to map and fit bounds
                route.line.addTo(map);
                
                // Add start and end markers
                if (trackPoints.length > 0) {
                    const startPoint = trackPoints[0];
                    const endPoint = trackPoints[trackPoints.length - 1];
                    
                    L.marker([startPoint[0], startPoint[1]], {
                        title: `Stage ${stageIndex + 1} Start`,
                        icon: L.icon({
                            iconUrl: 'https://unpkg.com/leaflet@1.9.4/dist/images/marker-icon.png',
                            iconSize: [15, 25], // Reduce from default [25, 41] to smaller size
                            iconAnchor: [7, 25], // Adjust anchor point accordingly
                            popupAnchor: [1, -22] // Adjust popup anchor accordingly
                        })
                    }).addTo(map)
                    .bindPopup(`<strong>Stage ${stageIndex + 1} Start</strong>`);
                    
                    L.marker([endPoint[0], endPoint[1]], {
                        title: `Stage ${stageIndex + 1} End`,
                        icon: L.icon({
                            iconUrl: 'https://unpkg.com/leaflet@1.9.4/dist/images/marker-icon.png',
                            iconSize: [15, 25], // Reduce from default [25, 41] to smaller size
                            iconAnchor: [7, 25], // Adjust anchor point accordingly
                            popupAnchor: [1, -22] // Adjust popup anchor accordingly
                        })
                    }).addTo(map)
                    .bindPopup(`<strong>Stage ${stageIndex + 1} End</strong>`);
                }
                
                return route;
            } catch (error) {
                console.error(`Error loading GPX for stage ${stageIndex + 1}:`, error);
                return null;
            }
        }
        
        // Calculate distance of a route
        function calculateRouteDistance(points) {
            let distance = 0;
            for (let i = 1; i < points.length; i++) {
                const prevPoint = L.latLng(points[i-1][0], points[i-1][1]);
                const currPoint = L.latLng(points[i][0], points[i][1]);
                distance += prevPoint.distanceTo(currPoint);
            }
            return distance / 1000; // Convert to kilometers
        }
        
        // Calculate elevation gain
        function calculateElevationGain(points) {
            let gain = 0;
            for (let i = 1; i < points.length; i++) {
                const elevDiff = points[i][2] - points[i-1][2];
                if (elevDiff > 0) {
                    gain += elevDiff;
                }
            }
            return gain;
        }
        
        // Function to handle stage dropdown change
        function handleStageChange() {
            const dropdown = document.getElementById('stage-dropdown');
            const selectedValue = parseInt(dropdown.value);
            
            if (selectedValue === -1) {
                // Whole trip selected - show all stages and fit all bounds
                showWholeTrip();
            } else {
                // Individual stage selected
                focusOnStage(selectedValue);
                createElevationProfile(selectedValue);
            }
        }
        
        // Function to show the whole trip
        function showWholeTrip() {
            // Zoom to fit all routes
            const bounds = [];
            let totalDistance = 0;
            let totalElevation = 0;
            
            for (let i = 0; i < routes.stages.length; i++) {
                if (routes.stages[i]) {
                    const stage = routes.stages[i];
                    const stagePoints = stage.points.map(p => [p[0], p[1]]);
                    bounds.push(...stagePoints);
                    
                    // Sum up stats
                    totalDistance += stage.distance;
                    totalElevation += stage.elevation;
                }
            }
            
            if (bounds.length > 0) {
                map.fitBounds(bounds.map(p => L.latLng(p[0], p[1])));
                
                // Update display
                document.getElementById('current-stage').textContent = `All`;
                document.getElementById('distance-traveled').textContent = totalDistance.toFixed(1);
                document.getElementById('elevation-gain').textContent = totalElevation.toFixed(0);
            } else {
                // Fallback to Switzerland view if no routes loaded
                map.setView([46.8182, 8.2275], 8);
            }
            
            // Clear elevation profile when showing whole trip
            const profileContainer = document.getElementById('profileContainer');
            profileContainer.innerHTML = '';
        }
        
        // Focus on a specific stage
        function focusOnStage(stageIndex) {
            if (routes.stages[stageIndex]) {
                const route = routes.stages[stageIndex];
                map.fitBounds(route.line.getBounds());
                
                // Update current stage display
                document.getElementById('current-stage').textContent = `${stageIndex + 1}/11`;
                
                // Update elevation display
                document.getElementById('elevation-gain').textContent = 
                    route.elevation.toFixed(0);
                
                // Update distance display
                document.getElementById('distance-traveled').textContent = 
                    route.distance.toFixed(1);
            }
        }

        // Helper function to extract location from image
        async function extractLocationFromImage(file) {
        return new Promise((resolve) => {
            const reader = new FileReader();
            
            reader.onload = function(e) {
            const exif = EXIF.readFromBinaryFile(e.target.result);
            
            if (exif && exif.GPSLatitude && exif.GPSLongitude) {
                // Convert GPS coordinates to decimal degrees
                const lat = convertDMSToDD(exif.GPSLatitude, exif.GPSLatitudeRef);
                const lon = convertDMSToDD(exif.GPSLongitude, exif.GPSLongitudeRef);
                
                resolve({ lat, lon });
            } else {
                resolve(null);
            }
            };
            
            reader.readAsArrayBuffer(file);
        });
        }

        // Function to update position from Spot Gen4
        function updatePosition(lat, lon, timestamp) {
            if (!currentPosition) {
                positionMarker.setLatLng([lat, lon]).addTo(map);
            } else {
                positionMarker.setLatLng([lat, lon]);
            }
            
            currentPosition = [lat, lon];
            actualPath.push(currentPosition);
            
            // Update actual path line
            if (!pathLine) {
                pathLine = L.polyline(actualPath, {
                    color: '#e63946',
                    weight: 5,
                    opacity: 0.8
                }).addTo(map);
            } else {
                pathLine.setLatLngs(actualPath);
            }
            
            // Update last update time
            const updateTime = new Date(timestamp);
            document.getElementById('last-update').textContent = 
                'Last updated: ' + updateTime.toLocaleString();
            
            // Determine current stage based on position
            determineCurrentStage(lat, lon);
        }
        
        // Determine which stage the cyclist is currently on
        function determineCurrentStage(lat, lon) {
            const position = L.latLng(lat, lon);
            let closestStage = 0;
            let closestDistance = Infinity;
            
            for (let i = 0; i < routes.stages.length; i++) {
                if (routes.stages[i]) {
                    const stage = routes.stages[i];
                    const routePoints = stage.points.map(p => L.latLng(p[0], p[1]));
                    
                    // Find closest point on this route
                    let minDistance = Infinity;
                    for (const point of routePoints) {
                        const distance = position.distanceTo(point);
                        if (distance < minDistance) {
                            minDistance = distance;
                        }
                    }
                    
                    if (minDistance < closestDistance) {
                        closestDistance = minDistance;
                        closestStage = i;
                    }
                }
            }
            
            // Update current stage if it changed
            if (routes.current !== closestStage) {
                routes.current = closestStage;
                
                // Update dropdown to reflect current stage
                document.getElementById('stage-dropdown').value = closestStage.toString();
                
                // Update stats display
                document.getElementById('current-stage').textContent = `${closestStage + 1}/11`;
                
                if (routes.stages[closestStage]) {
                    document.getElementById('elevation-gain').textContent = 
                        routes.stages[closestStage].elevation.toFixed(0);
                    document.getElementById('distance-traveled').textContent = 
                        routes.stages[closestStage].distance.toFixed(1);
                }
            }
        }
        
        // Function to add a photo
        function addPhoto(lat, lon, imageUrl, caption, timestamp) {
            // Create a photo object
            const photo = {
                position: [lat, lon],
                imageUrl: imageUrl,
                caption: caption,
                timestamp: timestamp
            };
            
            photos.push(photo);
            
            // Add photo marker to map
            const photoMarker = L.marker([lat, lon], {
                icon: L.divIcon({
                    html: 'üì∑',
                    className: 'photo-icon',
                    iconSize: [30, 30],
                    iconAnchor: [15, 15]
                })
            }).addTo(map);
            
            // Create popup with photo
            const popupContent = `
                <div class="photo-popup">
                    <img src="${imageUrl}" class="popup-image" alt="Photo">
                    <div>${caption}</div>
                    <div class="popup-time">${new Date(timestamp).toLocaleString()}</div>
                </div>
            `;
            
            photoMarker.bindPopup(popupContent, {
                className: 'custom-popup',
                maxWidth: 250
            });
            
            // Add to gallery
            const gallery = document.getElementById('photo-gallery');
            const thumbnail = document.createElement('img');
            thumbnail.src = imageUrl;
            thumbnail.className = 'photo-thumbnail';
            thumbnail.setAttribute('data-index', photos.length - 1);
            thumbnail.addEventListener('click', function() {
                openPhotoModal(parseInt(this.getAttribute('data-index')));
            });
            
            gallery.appendChild(thumbnail);
            
            // Update photo count
            document.getElementById('photos-shared').textContent = photos.length;
        }
        
        // Function to open the photo modal
        function openPhotoModal(index) {
            const photo = photos[index];
            document.getElementById('modal-image').src = photo.imageUrl;
            document.getElementById('modal-caption').textContent = 
                photo.caption + ' - ' + new Date(photo.timestamp).toLocaleString();
            document.getElementById('photo-modal').style.display = 'flex';
        }
        
        // Function to close the photo modal
        document.getElementById('close-modal').addEventListener('click', function() {
            document.getElementById('photo-modal').style.display = 'none';
        });


        // Function to create elevation profile for a stage
        function createElevationProfile(stageIndex) {
            if (!routes.stages[stageIndex]) return;
            
            const profileContainer = document.getElementById('profileContainer');
            profileContainer.innerHTML = '';
            
            // Create canvas for the chart
            const canvas = document.createElement('canvas');
            canvas.id = 'elevationChart';
            profileContainer.appendChild(canvas);
            
            // Extract elevation data from stage
            const stage = routes.stages[stageIndex];
            const elevationData = stage.points.map((point, index) => {
                // Calculate distance from start for each point
                let distanceFromStart = 0;
                if (index > 0) {
                    for (let i = 1; i <= index; i++) {
                        const prevPoint = L.latLng(stage.points[i-1][0], stage.points[i-1][1]);
                        const currPoint = L.latLng(stage.points[i][0], stage.points[i][1]);
                        distanceFromStart += prevPoint.distanceTo(currPoint);
                    }
                }
                
                return {
                    distance: distanceFromStart / 1000, // km
                    elevation: point[2],
                    lat: point[0],
                    lon: point[1],
                    index: index
                };
            });

            // Create position marker for hovering
            const hoverMarker = L.circleMarker([0, 0], {
                radius: 8,
                color: '#ff0000',
                fillColor: '#ff0000',
                fillOpacity: 0.5,
                weight: 2
            });
            
            // Create chart
            if (window.Chart) {
                const ctx = document.getElementById('elevationChart').getContext('2d');
                const chart = new Chart(ctx, {
                    type: 'line',
                    data: {
                        datasets: [{
                            label: `Elevation Profile - Stage ${stageIndex + 1}`,
                            data: elevationData,
                            borderColor: stageColors[stageIndex],
                            backgroundColor: `${stageColors[stageIndex]}80`,
                            borderWidth: 2,
                            pointRadius: 0,
                            fill: true // Enable fill under the line
                        }]
                    },
                    // Inside the createElevationProfile function, modify the options section of the Chart configuration:
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        parsing: {
                            xAxisKey: 'distance',
                            yAxisKey: 'elevation'
                        },
                        scales: {
                            x: {
                                type: 'linear',
                                title: {
                                    display: true,
                                    text: 'Distance (km)'
                                }
                            },
                            y: {
                                title: {
                                    display: true,
                                    text: 'Elevation (m)'
                                }
                            }
                        },
                        plugins: {
                            legend: {
                                display: false // Hide the legend
                            },
                            title: {
                                display: true,
                                text: `Elevation Profile - Stage ${stageIndex + 1}`
                            },
                            tooltip: {
                                mode: 'index',
                                intersect: false,
                                displayColors: false, // This removes the colored box
                                callbacks: {
                                    title: function(context) {
                                    return `Distance: ${context[0].raw.distance.toFixed(1)} km\nElevation: ${context[0].raw.elevation.toFixed(0)} m`;
                                    },
                                    label: function(context) {
                                    return ``;
                                    }
                                }
                            }
                        },
                        interaction: {
                            mode: 'index',
                            intersect: false
                        }
                    }
                });
                            
                // Add mouse event listeners to handle hover
                canvas.addEventListener('mousemove', function(event) {
                    const points = chart.getElementsAtEventForMode(event, 'index', { intersect: false });
                    if (points.length > 0) {
                        const dataIndex = points[0].index;
                        const pointData = elevationData[dataIndex];
                        
                        // Update marker position
                        hoverMarker.setLatLng([pointData.lat, pointData.lon]);
                        
                        // Add marker to map if not already added
                        if (!map.hasLayer(hoverMarker)) {
                            hoverMarker.addTo(map);
                        }
                    }
                });
                            
                // Remove marker when mouse leaves the chart
                canvas.addEventListener('mouseout', function() {
                    if (map.hasLayer(hoverMarker)) {
                        map.removeLayer(hoverMarker);
                    }
                });
            }
        }

        // Load GPX files - replace these URLs with your actual GPX files
        async function loadGPXFiles() {
            // Add event listener for dropdown
            document.getElementById('stage-dropdown').addEventListener('change', handleStageChange);
            
            // Load stages
            parseGPX('https://raw.githubusercontent.com/JonathanBurez/JonathanBurez.github.io/refs/heads/main/Day01.gpx', 0);
            parseGPX('https://raw.githubusercontent.com/JonathanBurez/JonathanBurez.github.io/refs/heads/main/Day02.gpx', 1);
            parseGPX('https://raw.githubusercontent.com/JonathanBurez/JonathanBurez.github.io/refs/heads/main/Day03.gpx', 2);
            parseGPX('https://raw.githubusercontent.com/JonathanBurez/JonathanBurez.github.io/refs/heads/main/Day04.gpx', 3);
            parseGPX('https://raw.githubusercontent.com/JonathanBurez/JonathanBurez.github.io/refs/heads/main/Day05.gpx', 4);
            parseGPX('https://raw.githubusercontent.com/JonathanBurez/JonathanBurez.github.io/refs/heads/main/Day06.gpx', 5);
            parseGPX('https://raw.githubusercontent.com/JonathanBurez/JonathanBurez.github.io/refs/heads/main/Day07.gpx', 6);
            parseGPX('https://raw.githubusercontent.com/JonathanBurez/JonathanBurez.github.io/refs/heads/main/Day08.gpx', 7);
            parseGPX('https://raw.githubusercontent.com/JonathanBurez/JonathanBurez.github.io/refs/heads/main/Day09.gpx', 8);
            parseGPX('https://raw.githubusercontent.com/JonathanBurez/JonathanBurez.github.io/refs/heads/main/Day10.gpx', 9);
            parseGPX('https://raw.githubusercontent.com/JonathanBurez/JonathanBurez.github.io/refs/heads/main/Day11.gpx', 10);
            
            // Initialize with whole trip view
            setTimeout(showWholeTrip, 1000);
        }
        
        // Function to fetch spot data
        async function fetchSpotData() {
            try {
                // In a real implementation, you would connect to Spot API or feed
                // Example: `https://api.findmespot.com/spot-main-web/consumer/rest-api/2.0/public/feed/{feed-id}/message.json`
                
                const response = await fetch('YOUR_SPOT_API_ENDPOINT');
                const data = await response.json();
                
                // Process Spot data and update the map
                // This would depend on the structure of the Spot API response
                if (data && data.messages && data.messages.length > 0) {
                    const latestMessage = data.messages[0];
                    
                    // Update position (format depends on Spot API)
                    updatePosition(
                        latestMessage.latitude,
                        latestMessage.longitude,
                        latestMessage.dateTime
                    );
                }
            } catch (error) {
                console.error('Error fetching Spot data:', error);
            }
        }

        // Add this function and call it from your initApp() to test display
        function addTestPhoto() {
            
            const testUrl = "https://www.dropbox.com/scl/fi/uy0byx81rzef02ep2a8jo/2025-04-03-16.55.09.heic?rlkey=7ygsboc0ryox8li3wtjrve7so&st=ol72cn9y&dl=1"
            addPhoto(46.8182, 8.2275, testUrl, "Dropbox v3 Photo", new Date().toISOString());
            console.log("Test photo added");
        }
// Modify initialization to wait for Chart.js
async function initApp() {
    // First load Chart.js
    await loadChartJS();

    // Then load GPX routes
    await loadGPXFiles();
    
    // Add the info panel header and toggle functionality
    const infoPanel = document.getElementById('info-panel');
    const infoPanelContent = infoPanel.innerHTML;
    
    // Wrap existing content in the panel content div
    infoPanel.innerHTML = `
        <div class="info-panel-header">
            <h3 class="info-panel-title">Trip Information</h3>
            <span class="info-panel-toggle">‚ñº</span>
        </div>
        <div class="info-panel-content">
                  <div id="trip-stats">
                      <div class="stat-box">
                          <div class="stat-value" id="current-stage">0/11</div>
                          <div class="stat-label">Current Stage</div>
                      </div>
                      <div class="stat-box">
                          <div class="stat-value" id="distance-traveled">0</div>
                          <div class="stat-label">Kilometers</div>
                      </div>
                      <div class="stat-box">
                          <div class="stat-value" id="elevation-gain">0</div>
                          <div class="stat-label">Meters Climbed</div>
                      </div>
                      <div class="stat-box">
                          <div class="stat-value" id="photos-shared">0</div>
                          <div class="stat-label">Photos Shared</div>
                      </div>
                  </div>
                  <h2>Latest Photos</h2>
                  <div id="photo-gallery">
                      <!-- Photos will be added here dynamically -->
                  </div>
                  <div id="last-update">Last updated: Not yet started</div>
        </div>
    `;
    // Inside the initApp function, after setting the infoPanel.innerHTML, add this line:
    infoPanel.classList.add('info-panel-collapsed');

    // And change the toggle text:
    const toggle = document.querySelector('.info-panel-toggle');
    toggle.textContent = '‚ñ≤';
    // Add event listener for toggle
    document.querySelector('.info-panel-header').addEventListener('click', function() {
        const panel = document.getElementById('info-panel');
        panel.classList.toggle('info-panel-collapsed');
        
        const toggle = document.querySelector('.info-panel-toggle');
        if (panel.classList.contains('info-panel-collapsed')) {
            toggle.textContent = '‚ñ≤';
        } else {
            toggle.textContent = '‚ñº';
        }
    });
    addTestPhoto();
}
        
        // Start the application
        initApp();
        
        // DEMO FUNCTIONS - For testing only
        function runDemo() {
            // Simulate a journey along the first stage
            let progress = 0;
            
            // Update position every 5 seconds in the demo
            const positionInterval = setInterval(() => {
                if (!routes.stages[0] || progress >= 1) {
                    clearInterval(positionInterval);
                    return;
                }
                
                const points = routes.stages[0].points;
                const pointIndex = Math.floor(progress * (points.length - 1));
                
                // Update the position
                updatePosition(
                    points[pointIndex][0],
                    points[pointIndex][1],
                    new Date().toISOString()
                );
                
                // Move along the route
                progress += 0.05;
                
                // Add a photo occasionally
                if (Math.random() < 0.2) {
                    addPhoto(
                        points[pointIndex][0],
                        points[pointIndex][1],
                        "/api/placeholder/400/300",
                        `Beautiful views from Day 1!`,
                        new Date().toISOString()
                    );
                }
            }, 5000);
        }
        
        // Uncomment to run the demo
        // setTimeout(runDemo, 2000);
    </script>
</body>
</html>
